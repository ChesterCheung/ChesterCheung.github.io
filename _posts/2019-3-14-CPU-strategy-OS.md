---
layout: post
title:  "CPU的调度策略"
categories: OS
tags:  OS CPU
author: Chester Cheung
---

* content
{:toc}


今天见到介绍下CPU处理器的调度策略，自己也还在学习中，后期会继续完善补充，有什么不足希望大家多多指教。


## 首先介绍下CPU调度的相关概念


CPU的调度简单来说，就是当前的进程需要进行的OI操作或者时间片结束后，操作系统需要从就绪的队列中选择一个进程，把CPU的使用权赋给被选择的进程，如果没有就绪进程的话，系统会自动安排一个空闲进程或idle进程(windows操作系统中都存在的system idle process)，目的就是让CPU不空闲，这类进程所占CPU的百分比越高，就说明系统比较空闲。











CPU的调度主要会发生在，内核对中断、异常、系统调用后还返回到用户态时，现在假设有M个进程，N个CPU需要分配给他们来运行，那么哪个CPU分配给哪个进程？是在什么时候通过什么方式分配的？

**总的来说有以下几种情况：

**

1.进程正常结束，或由于某种错误而终止运行


2.新进程创建，或一个等待进程变成就绪状态


3.当一个进程从进行态变为阻塞态


4.当一个进程从运行态变为就绪态


前两种是CPU上有进程在运行，后两种是CPU上没有进程在运行时的调度。
CPU调度算法有几个衡量的指标：



1.吞吐量(Throughput)：单位时间完成的进程数目


2.周转时间(Turnaround Time)：每个进程从提出运行请求道运行完成的时间


3.响应时间(Response Time)：从提出请求道第一次回应的时间


4.CPU的利用率(CPU Utilization)：CPU有效工作所占的时间比例

5.
等待时间(Waiting Time)：每个进程在就绪队列中等待的时间
等等一系列标准……


## I/O密集型与CPU密集型：


**I/O密集型**：进程的大部分时间都是在等待I/O设备上

![1](https://img-blog.csdnimg.cn/20190314220943863.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM5MDE0NQ==,size_16,color_FFFFFF,t_70)



**CPU密集型**：需要大量CPU的时间来计算


![2](https://img-blog.csdnimg.cn/20190314220954607.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM5MDE0NQ==,size_16,color_FFFFFF,t_70)



**区分静态优先级和动态优先级**：


静态优先级：进程创建时指定，运行过程中不再改变


动态优先级：进程创建时指定了一个优先级，运行过程中可以动态变化
如：等待时间较长的进程可提升其优先级



## 下面再来介绍几种CPU调度的算法：


**先进先出算法FIFO((First In First Out)**



按照进程就绪的先后顺序来使用CPU，处理器被分配给最先进入就绪队列的进程，进程一单分到CPU的使用权，就一直执行到进程结束或阻塞时才结束。这种进程按照时间顺序来使用，非抢占内存的方式，公平公正，实现起来也相对简单；但是算法的实际效果不佳，比如在长进程后的短进程，必须等到长进程执行完毕后才能执行，不利于有效的提升用户体验。再形象化一点，有3个进程p1，p2，p3，执行期分别为30,20,10，当他们分别进入就绪队列时，对于p1,p2,p3的周转时间分别为30,50,60，平均的周转时间是46.7，可见效率确实不高。



**短进程优先算法SCBF(Shortest CPU Burst First)**



先给每个进程都设置一个优先级，根据比较优先级来确定下一个执行的进程；将一些相对短的进程优先级适当提高，该算法虽然可获得较好的调度性能，用户体验也有所提升，但是难以准确的知道下一个CPU的执行期，只能根据每一个进程的执行历史来预测；不知道进程的具体执行时间，他的优先级还有可能继续改变，所以仍然有所缺陷。



**时间片轮转调度算法RR(Round Robin)
**


分配给调度上CPU的进程，确定了允许该进程运行的时间长度。每个进程会被分配一个时间片，在这个时间片的时间段内，允许进程运行；如果在时间片结束时该进程还在运行，就会剥夺该进程得而CPU并分配给另一个进程；如果该进程在时间片结束前终止或者阻塞，则CPU会立即完成任务并进行切换。这种算法有利于交互式计算，响应的速度快，但是由于进程的切换，时间片轮转法要花费较多的内存开销，而且对于彼此进程间相差较大的有利，而对于进程大小相似或相同的则不利。



**虚拟轮转法(Virtual RR)**



这种算法基于时间片轮转法进行改进，能够解决在CPU调度中对于进程大小相似的进程集的不利性，主要特点就是设置了一个辅助的队列，每一个进程在执行完毕一个时间片后，就进入辅助队列，CPU在进行调度是总是先来检查辅助队列是否为空队列，若不为空则优先执行辅助队列中的进程，直到辅助队列为空，再调度就绪队列中的进程。



**优先级算法PSA(Priority Scheduling Algorithm)**



给每一个进程一个优先级，优先级越高的事件越紧急，应该先执行，一般来说，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏向于I/O类型的进程。这种算法实现起来简单，但是缺乏公平性，很可能导致优先级低的进程产生饥饿现象，会造成优先级反转的问题，就是一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行完毕后再运行。
