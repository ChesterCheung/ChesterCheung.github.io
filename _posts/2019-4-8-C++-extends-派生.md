---
layout: post
title:  "扫除C++继承/派生难点、痛点"
categories: C++
tags: C++ 继承 派生
author: Chester Cheung
---

* content
{:toc}


学习了Java以后，在学习C++的过程中总感觉C++要比Java麻烦些，可能每种语言都有自己的特点吧，C++中就有一些Java不具备的功能，比如多继承。今天下午自己学习了C++继承的一些相关知识和用法，不过具体的代码能力还有待提高和加强，先把一些心得体会写下来，帮助大家更好的理解。



## 继承


首先关于继承的相关概念就不多说了，用简单的例子来说明就ok：


可以定义一个学生Student类，这个类具有的属性是学习study和生活live；现在需要再定义一个Junior Student初中生类，属性是学习study、生活live和上学school，还需要定义一个Senior Student高中生类，属性是学习study、生活live和conduct做实验。如果在每个类中进行重新定义，会造成代码量增加而且代码的可读性变差的缺点，所以就有了继承这个面向对象编程的特点，通过继承，不仅能理清楚每个对象之间的关系，还能有效减少代码量，增强代码的可读性。



在Java中，继承需要用到关键字extends，但在C++中，我们用到不同的表示方法。

```php
	class 派生类名 ： [继承方式] 基类名 {
		派生类新增加的成员
	}；
```

即在继承中，派生类不仅可以继承到基类中的数据成员和成员函数，还能添加自己所特有的数据成员和成员函数。注意：派生类在继承基类中的东西时，是全部继承，不可以选择的。但是，构造函数和析构函数都是不能继承的，要在派生类中重新写出来。继承的方式一共分为三种：public(公用的), private(私有的), protected(受保护的)，C++默认的继承方式是private私有继承。



## 继承方式


不同继承方式中的成员的访问属性不同，所以才会分成三种进行限定访问属性，接下来就大概较为详细地介绍下每种继承方式的特点：

![1](https://img-blog.csdnimg.cn/20190408164524143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDM5MDE0NQ==,size_16,color_FFFFFF,t_70)

> 1.公用继承



基类的公用成员和保护成员在派生类仍然保持原来公用成员和保护成员的性质，但基类的私有成员在派生类中并没有成为派生类的私有成员，而仍是基类的私有成员，所以只能被基类的成员函数引用，而不能被派生类的成员函数引用。



> 2.私有继承



私有基类的公用成员和保护成员在派生类中的访问属性相当于派生类中的私有成员，而私有基类中的私有成员在派生类中是不能访问的成员，只有基类的成员函数可以引用他们。如果将某个继承声明为私有继承，就表示能将这个基类中能被外界引用的成员隐藏起来，不让外界再引用。这样，将不需要再往下继承的类的功能用私有继承的方式把他隐藏起来，下一层的派生类就无法访问他的任何成员了。



> 3.保护继承



保护基类的公有成员和保护成员都在派生类中成了保护成员，其私有成员仍为基类私有，也就是把基类原有的公用成员保护起来，不让类外任意访问。
具体说明

，如果以私有继承的方式派生出一个新的派生类，原来私有基类中的成员在新派生类中都成为不可访问的成员，无论在派生类内还是类外都不可访问；

如果以保护继承的方式，原来保护基类中的共有成员和保护成员都成为保护成员，可以被新的派生类中的成员函数访问，但在派生类外仍然不能访问。



上面这些概念相对来说还是有点难懂的，仅仅靠看的话真的比较麻烦，还需要多写代码熟练一下。



## 多级派生时的访问属性


我们在实际写代码的过程中很少使用多级派生，因为这样会提高出错率。如果在多级派生时都采用公有继承方法，那么直到最后一级派生类都可以访问基类中的公有成员和成员函数；如果采用的是私有继承，经过若干次派生后，基类的所有成员就已经变成不可访问的了；如果采用保护继承，在派生类外是无法访问派生类中的任何成员的。


经过多次派生后，人们很难记清哪些成员是可以访问的，这样真的很容易出错，因此我们实际编程中常用的是公有继承。


## 派生类的构造函数

```php
派生类构造函数的一般形式是：

	派生类构造函数名(总参数表) : 基类构造函数名(参数表) {
		派生类中新增数据成员的初始化语句
	}
```

总参数表中包括基类中的数据成员和派生类中新增的数据成员，在建立一个对象时，调用构造函数的顺序是1.派生类的构造函数先调用基类构造函数 2.再执行派生类构造函数本身(即派生类构造函数的函数体)



类似的，派生类对象在释放时，先执行派生类析构函数，再执行基类析构函数(就是顺序和构造函数反过来)

> 需要注意一点

有子对象的派生类的构造函数比较特殊，子对象的定义和定义C语言中的结构体链表相似，比如在声明一个类时包括这样的数据成员：

```php
	Student s		//Student 是已声明的类名，s是对象
```

这里的s就是类对象中的内嵌成员，成为子对象，即把一个该类的对象作为该类的一个数据成员，这时候定义构造函数的一般形式为：

```php
	派生类构造函数名(总参数表) : 基类构造函数名(参数表) , 字对象名(参数表) {
		派生类中新增的数据成员初始化语句
	}
```

> 多层派生的构造函数

在写多层派生的古朴早函数时，不需要写出每一层派生的构造函数，只需写出其上一层派生类(即他的直接基类)的构造函数即可。