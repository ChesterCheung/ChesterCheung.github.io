---
layout: post
title:  "Nosql之Memcached分布式对象缓存"
categories: database
tags: database Nosql
author: Chester Cheung
---

* content
{:toc}

Memcached是一种高性能的分布式对象缓存系统，可以用来保存一些经常存取的对象或数据，保存的数据像一张巨大的HASH表，该表以Key-value对的方式存在内存中。它属于nosql一个比较简单可用的例子，在这里快速学习下，为学习其他数据库进行准备......

### Memcached作用

传统场景中，多数Web应用都将数据保存到关系型数据库中（例如：MySQL），Web服务器从中读取数据并在浏览器中显示。<u>但随着数据量的增大，访问的集中，关系型数据库的负担就会出现加重，响应缓慢，导致网站打开延迟等问题，影响用户体验。
这时就需要Memcached软件出马了。</u> **使用Memcached的主要目的是，通过在自身内存中缓存关系型数据库的查询结果，减少数据库被访问的次数，以提高动态Web应用的速度，提高网站架构的并发能力和可扩展性。**

Memcached服务的运行原理是通过在事先规划好的系统内存空间中临时缓存数据库中的各类数据，以达到减少前端业务服务对数据库的直接高并发访问，从而提升大规模网站集群中动态服务的并发访问能力。 

生产场景的Memcached服务一般被用来保存网站中经常被读取的对象或数据，就像我们的客户端浏览器也会把经常访问的网页缓存起来一样，通过内存缓存来存取对象或数据要比磁盘存取快很多，因为磁盘是机械的，因此，在当今的IT企业中，Memcached的应用范围很广泛。

### Memcached工作流程

从逻辑上来说，当程序访问后端数据库获取数据时会优先访问Memcached缓存，如果缓存中有数据就直接返回给客户端用户，如果没有合适的数据（没有命中），再去后端的数据库读取数据，读取到需要的数据后，就会把数据返回给客户端，同时还会把读取到的数据缓存到Memcached内存中，这样客户端用户再次请求相同的数据时就会直接读取Memcached缓存的数据了，这就大大地减轻了后端数据库的压力，并提高了整个网站的响应速度，提升了用户体验。

> 在学习之前，要注意区分Memcached的几个特点：

1. 协议相对简单，可以直接通过telnet访问Memcached服务器，进行存取数据的操作

2. 所有数据都保存在内存中，存取数据比硬盘快，当内存满后，通过LRU算法自动删除不使用的缓存，但没有考虑数据的容灾问题，重启服务后，所有数据会丢失。

3. 各个memcached服务器之间互不通信，各自独立存取数据，不共享任何信息。注意，Memcached服务器本身并不具有分布式功能，分布式部署取决于memcache客户端。

### Memcached语法

Memcached基础语法很少，基本只有很简单的一些，只要把常用的掌握就OK：

```php
telnet localhost 11211
```






先连接上localhost的11211，是memcached的默认端口，连接上后即可直接输入memcached命令；然后通过set和get这两个配套的命令可以设置和查询到对应的key，value对的值是多少

```php
set ‘key’ 'flag' 'expires' 'byte'

get 'key'
```

然后通过incr和append命令可以给key对应的value增加值或者字符串

```php
incr 'key' 'num'

append 'key' 'string' 'expires' 'byte'
```

还有delete和flush_all可以分别删除一个或者全局的所有key

```php
delete 'key'

flush_all
```

以上就是memcached的常用命令，简单吧～

### 安装memcached相关包(针对macOS平台)：

首先ruby是必备的环境(macOS默认自带ruby)

> $ brew install ruby

安装ruby的依赖包

> $ brew install rubygems

注意下一步可能有安装权限问题，可以通过sudo gem install memcach-client

> $ gem install memcach-client

### 单节点测试Ruby程序

```php

$KCODE='u'

require "rubygems"
require "memcache"

server=['localhost:11211']
option={}

cache=MemCache.new(server,option)

cache['key1']=123
cache['key2']="ABCDE"
cache['key3']=%w(hoge fuga)
cache['key4']={:foo=>1,:bar=>"a"}

p cache['key1']
p cache['key2']
p cache['key3']
p cache['key4']

```

![2019-10-12-1](https://zhyChesterCheung.github.io/photos/2019-10-12-1.png)

### 用Ruby程序测试多个memcached节点

> 节点分配算法：**一致性哈希算法Consistent Hashing**

当向memcached集群存入/取出key/value时，memcached客户端程序根据一定的算法计算存入哪台服务器，然后再把key/value值存到此服务器中。也就是说，存取数据分二步走：第一步，选择服务器，第二步存取数据。

监听端口: 11211，11212，11213

```php
require "rubygems"
require "memcache"
require "logger"

server=['localhost:11211','localhost:11212','localhost:11213']

option={
    :logger=>Logger.new(STDOUT)
}

cache=MemCache.new(server,option)

cache['key1']=123
cache['key2']="ABCDE"
cache['key3']=%w(hoge fuga)
cache['key4']={:foo=>1,:bar=>"a"}

p cache['key1']
p cache['key2']
p cache['key3']
p cache['key4']
```

![2019-10-12-2](https://zhyChesterCheung.github.io/photos/2019-10-12-2.png)

### 模拟失去一个节点

```php
require "rubygems"
require "memcache"
require "logger"

server=['localhost:11212','localhost:11213']

option={
    :logger=>Logger.new(STDOUT)
}

cache=MemCache.new(server,option)

cache['key1']=123
cache['key2']="ABCDE"
cache['key3']=%w(hoge fuga)
cache['key4']={:foo=>1,:bar=>"a"}

p cache['key1']
p cache['key2']
p cache['key3']
p cache['key4']
```

![2019-10-12-3](https://zhyChesterCheung.github.io/photos/2019-10-12-3.png)

> Memcached stats ——命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。

> Memcached flush_all 命令用于清理缓存中的所有 key=>value(键=>值) 对。

```php
flush_all [time] [noreply]
```

> Memcached replace 命令用于替换已存在的 key(键) 的 value(数据值)。

```php
replace key flags exptime bytes [noreply]
value
```

> Memcached append 命令用于向已存在 key(键) 的 value(数据值) 后面追加数据 。

```php
append key flags exptime bytes [noreply]
value
```

> Memcached prepend 命令用于向已存在 key(键) 的 value(数据值) 前面追加数据 。

```php
prepend key flags exptime bytes [noreply]
value
```

> Memcached replace 命令用于替换已存在的 key(键) 的 value(数据值)。
如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。

```php
replace key flags exptime bytes [noreply]
value
```


### Memcached内存管理机制深入剖析

1. Malloc内存管理机制

在讲解Memcached内存管理机制前，先来了解malloc

> malloc的全称是memory allocation，中文名称<u>动态内存分配</u>，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态分配内存。

> 早期的Memcached内存管理是通过malloc分配的内存实现的1，使用完后通过free来回收内存。这种方式容易产生内存碎片并降低操作系统对内存的管理效率。因此，也会加重操作系统内存管理器的负担，最坏的情况下，会导致操作系统比Memcached进程本身还慢，为了解决上述问题，Slab Allocator内存分配机制就诞生了。

2. Slab内存管理机制

现在的Memcached是利用Slab Allocation机制来分配和管理内存的，过程如下：

> 提前将大内存分配大小为1MB的若干个slab，然后针对每个slab再进行小对象填充，这个小对象称为chunk，避免大量重复的初始化和清理，减轻了内存管理器的负担。 
Slab Allocation内存分配的原理是按照预先规定的大小，将分配给Memcached服务的内存预先分割成特定长度的内存块（chunk），再把尺寸相同的内存块（chunk）分成组（chunks slab class），这些内存块不会释放，可以重复利用，如下图所示。

![2019-10-12-2](https://zhyChesterCheung.github.io/photos/memcached1.png)

> 新增数据对象存储时。因Memcached服务器中保存着slab内空闲chunk的列表，他会根据该列表选择chunk，然后将数据缓存于其中。当有数据存入时，Memcached根据接收到的数据大小，选择最适合数据大小的slab分配一个能存下这个数据的最小内存块（chunk）。例如：有100字节的一个数据，就会被分配存入下面112字节的一个内存块中，这样会有12字节被浪费，这部分空间就不能被使用了，这也是Slab Allocator机制的一个缺点。

**Slab Allocator还可重复使用已分配的内存，即分配到的内存不释放，而是重复利用。**

3. Slab 内存管理机制特点

- 提前分配大内存Slab 1MB，再进行小对象填充chunk。

- 避免大量重复的初始化和清理，减轻内存管理器负担。

- 避免频繁malloc/free内存分配导致的碎片

> 下面对Mc的内存管理机制进行一个小结

- Mc的早期内存管理机制为malloc（动态内存分配）

- malloc（动态内存分配）产生内存碎片，导致操作系统性能急剧下降。

- Slab内存分配机制可以解决内存碎片的问题

- Memcached服务的内存预先分割成特定长度的内存块，称为chunk，用于缓存数据的内存空间或内存块，相当于磁盘的block，只不过磁盘的每一个block都是相等的，而chunk只有在同一个Slab Class内才是相等的。

- Slab Class指特定大小（1MB）的包含多个chunk的集合或组，一个Memcached包含多个Slab Class，每个Slab Class包含多个相同大小的chunk。

- Slab机制也有缺点，例如，Chunk的空间会有浪费等。

### Memcached的检测过期与删除机制

> Memcached懒惰检测对象过期机制

1. 首先要知道，Memcached不会主动检测item对象是否过期，而是在进行get操作时检查item对象是否过期以及是否应该删除！

2. 因为不会主动检测item对象是否过期，自然也就不会释放已分配给对象的内存空间了，除非为添加的数据设定过期时间或内存缓存满了，在数据过期后，客户端不能通过key取出它的值，其存储空间将被重新利用。

3. Memcached使用的这种策略为懒惰检测对象过期策略，即自己不监控存入的key/value对是否过期，而是在获取key值时查看记录的时间戳（sed key flag exptime bytes），从而检查key/value对空间是否过期。这种策略不会在过期检测上浪费CPU资源。

> Memcached懒惰删除对象机制

1. 当删除item对象时，一般不会释放内存空间，而是做删除标记，将指针放入slot回收插槽，下次分配的时候直接使用。

2. Memcached在分配空间时，会优先使用已经过期的key/value对空间；若分配的内存空间占满，Memcached就会使用LRU算法来分配空间，删除最近最少使用的key/value对，从而将其空间分配给新的key/value对。在某些情况下（完整缓存），如果不想使用LRU算法，那么可以通过“-M”参数来启动Memcached，这样，Memcached在内存耗尽时，会返回一个报错信息

### 某人在set存储memecache数据时候，将 $expire 设置为100天，发现设置的key总是获取不到值？

memcache默认过期时间是30天，过期时间用秒为单位或时间戳为单位，前一种情况秒数不能超过60×60×24×30（30天时间的秒数）;如果失效的值大于这个值， 服务端会将其作为一个真实的Unix时间戳来处理而不是自当前时间的偏移。如果过期时间设定为0，表示永不过期，但也不是相对的，有可能因为服务端为了给其他新的元素分配空间而被LRU算法删除。
