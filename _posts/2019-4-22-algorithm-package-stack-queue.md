---
layout: post
title:  "算法和数据结构——包、栈、队列"
date:   2019-4-22
categories: algorithm
tags: algorithm 数据结构
author: Chester Cheung
---

* content
{:toc}


许多基础的数据结构都是对象的集合的形式的，说白了，数据结构的值就是一组对象的集合，所有的操作都是关于添加、删除、访问集合中的对象。



那么这就要学习三种基础的数据结构了，分别是包、栈、和队列，他们的不同之处仅仅在于删除或访问对象的顺序不同。



在学习这几种数据结构之前，我们先介绍下泛型和迭代：










## 泛型



泛型也叫做参数化类型，他是一种集合类的抽象数据类型，关键特性是我们**可以通过他存储任意类型的数据**。其实，就是一种**普遍的数据类型，只是可以被任意的类型所替换**。



在创建栈对象时，实例化的对象会提供一种具体的数据类型，这时就可以将Item这种抽象的数据类型替换为具体的了(Item出现的每个位置都是如此)，使用泛型写出的代码很容易进行调试和修改代码。



Item是一种类型参数，用于表示用例将会使用的某种类型的象征性的占位符，我们并不知道Item准确的数据类型，但只需要在使用时提供具体的数据类型，他就能用栈处理任意的数据类型。实际的类型必须是引用类型,但是用例可以依靠自动装箱将原始数据转换成相应的封装类型。



但是有个细节要注意的：由于某些原因，以下的操作是不允许的：

```php
	Item a = new Item();
```

创建泛型数据在Java中是不被允许的，需要借助类型转换才能达到目的：

```php
	Item a = (Item())new Object();
```

## 自动装箱

类型参数在使用时，必须被实例化成引用类型，因此Java有一种特殊的机制来使泛型代码能够处理原始的数据类型。还记得Java封装类的相关知识吗？如果忘了，请移步到我的博客回顾一下：
[https://blog.csdn.net/weixin_44390145/article/details/87485778](https://blog.csdn.net/weixin_44390145/article/details/87485778)；



在处理赋值语句、方法的参数和算术或逻辑表达式的时候，Java会自动在引用类型(封装类的类型)和对应的原始数据类型之间转换。



自动装箱就是自动将一个原始数据类型转换成一个封装类型；

自动拆箱就是自动将一个封装类型转换成一个原始数据类型；



举个例子，从int到Integer就是自动装箱，而从Integer到int就是自动拆箱。



## 可迭代的数据类型



在大多数时候，使用数据结构的要求只是按照某种顺序处理集合中的每个元素，或者叫做迭代访问集合中的所有元素。有了这个，我们就可以写出清晰简洁的代码，而不依赖于仅仅靠数组的实现。



有趣的是，Stack和Queue的API唯一不同之处在于他们的名称和方法名，所以不能仅通过一组方法的签名就说明这种方法的全部特点和用法，只有自然语言的描述才能说明其中的具体规则和不同用法。



## 背包 Bag



背包是一种不支持从中删除元素的集合数据类型，目的就在于帮助收集元素并迭代遍历所有收集到的元素。迭代的顺序并不确定，而且与用例无关。



可以理解成这样，一个人往包里面收集弹球，一次一个，并且时不时到包中寻找某种特点的球，使用Bag的API，随时可以向包中添加元素，并且通过foreach可以访问到所有的元素，但是处理元素的顺序并不重要。


## 队列(先进先出)



先进先出队列是一种基于先进先出策略(FIFO)的集合类型。比如每天见到的排队，优先服务等待最久的人，这才符合先进先出原则，基本原则是公平。当使用foreach语句迭代访问其中的元素时，处理顺序就是他们被添加到队列中的顺序。使用队列的目的就是在使用集合保存元素的同时，还需要保存他们的相对顺序。



## 栈(下压)



栈是一种基于后进先出(LIFO)的策略的集合类型。在往一个箱子里装东西的时候，使用的就是一个栈。有东西来时，把东西从下往上累积放置，但是要把东西取出来的时候，就需要先把上面的东西拿掉以后，才能拿到下面的东西。再比如，好多人还是采用栈的方式读取电子邮件：有邮件来的时候优先累积在上面，而读取的时候还是从最新的邮件往下读取。



这种策略的好处是我们可以及时看到最新的消息，但坏处是不好的消息我们可能永远也看不到了。



当用foreach访问类型中的元素时，元素的处理顺序和他们输入的顺序正好相反。所以在应用程序中使用栈迭代器的原因就是，在用集合保存元素的同时，颠倒他们的相对顺序。在计算机领域，栈的意义十分重大。



就用一个简单的算数例子来简单说明一下他的作用：

(1+((2 * 3)*(4 * 5)))



他的解答过程是这样的：

(1+((2 * 3)*(4 * 5)))

(1+(5 * (4 * 5)))

(1+(5 * 20))

(1+100)

101



这个表达式由括号、运算符和操作的数字组成，需要进行以下的送入栈的过程：


1.将操作数压入操作数栈
2.将运算符压入运算符栈

3.忽略左括号

4.在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈

在处理完毕最后一个右括号后，操作栈上面只会剩下一个值，这个就是表达式的值，这个就是栈的一个基础运用。



## 垃圾游离：

Java垃圾回收的策略是回收所有无法被访问的对象的内存，在对pop()弹出的实现中，如果之前将栈中的每一个元素都移动到一个数组中的话，被弹出的元素的引用仍然存在于数组中，这个元素实际上已经是一个没办法访问到的孤儿了——他永远不会被访问到，但是Java的垃圾处理器没办法知道这一点，除非引用也被覆盖；即使用例已经不再需要这个元素了，数组中的引用仍然可以让他继续存在，这个元素就称为**游离**的。



但是要避免游离其实很简单：只需将被弹出的元素的值设为NULL即可，这将覆盖掉无用的引用，并使系统在用例使用完被弹出的元素后回收他的内存。
