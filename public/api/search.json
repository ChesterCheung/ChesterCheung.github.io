[{"id":"874828a6f7134332a608ce3bbd85a232","title":"理解区分IaaS、SaaS、PaaS的含义和区别","content":"相信你一定听说过IaaS、SaaS、PaaS等概念，这些都是云计算中的三个高大上的概念，但这几个术语其实并不好理解。不过，我们可以利用吃披萨🍕来给大家类比这几个概念的理解。\n类比披萨店吃披萨首先，一个吃货怎样才能吃到披萨呢？有以下几种方式：\n\n在家自己做\n\n但是你要准备的东西很多，材料、工具、烤箱……还需要经过发面、做面团、进烤箱等工序才能完成\n\n从披萨店买做好的披萨\n\n你只需要去披萨店买成品披萨，回家烘焙号了就可以在自己的餐桌上吃，和在家自己做不一样，你只需要一个pizza提供商\n\n打电话叫外卖\n\n打个电话把披萨叫到家中，pizza就送到家中，但你需要自己准备桌椅、苏打水等\n\n直接去披萨店吃\n\n你什么都不需要准备，连餐桌都是pizza店的\n下图就是我们可以吃到披萨的总结：\n\n企业端技术分层现在我们从披萨店变成一家超大型技术公司，根本不需要别人为我们提供服务，你拥有基础设施、应用等等一切，可以分为三层：基础设施infrastructure、平台platform、应用application\n\n这张图其实就是云计算的三个分层：基础设施在最底层、平台在中间层、软件应用在顶层，分别是：Infrastructure-as-a-Service(IaaS)，Platform-as-a-Service(PaaS)，Software-as-a-Service(SaaS)，别的一些“软的”层可以在这些层的基础上添加。\n\n如果你的公司什么都有，现在所处的状态叫本地部署，就想自己在家做披萨一样。你需要购买服务器以及其他硬件设备来控制本地应用，让你的业务代码运行起来，这就叫本地部署。\n\n假如有天boss想明白了，只是为了吃到pizza，没必要所有流程都自己完成。于是，他准备考虑一家云服务提供商，这个云服务提供商能提供哪些服务呢？\n\n\n","slug":"2020-6-10-SaaS","date":"2020-06-10T12:00:00.000Z","categories_index":"thinking","tags_index":"thinking","author_index":"Csuzhang"},{"id":"8483753522c9d846e8ac4a720d8703bb","title":"TOGAF企业架构体系","content":"TOGAF定义TOGAF 即 The Open Group Architecture Framework （开放组体系结构框架），是由致力于技术标准制定和推广的非盈利组织 The Open Group 制定的用于开发企业架构（Enterprise Architecture）的一套方法和工具。\n在介绍 TOGAF 之前，今天先来聊聊企业架构。企业架构由IT架构发展而来。所以在一些定义中，会把企业架构简单定义为企业信息系统建设的规划。\n\n\n\n\n\n\n\n\n\n上世纪七十年代美国军方想要建立一个牛X的系统来管理通讯指挥作战的所有相关资源，建立这个系统的方法后来形成理论并于2003年发展成 DoDAF （美国国防部体系架构框架）。在那之前，民间已经发展出好几个框架雏形。其中，1987美国人 John Zachman 发表论文首次提出了“信息系统架构框架”的概念（后改称“企业架构框架”），奠定了企业架构的理论基础。\n但其实现在我们讲的企业架构，一般包括业务架构（流程、组织）、应用架构（应用、服务）、数据架构（数据、信息）和技术架构（硬件、网络）这几方面内容。\n\n企业架构组成根据 TOGAF 的定义，企业是具有一系列共同目标的组织的集合。而企业架构则是为了有效地实现这一系列目标，去定义企业的结构和运作模式的概念蓝图（SearchCIO），是构成企业的所有关键元素和其关系的综合描述（Zachman），是通过创建、沟通和优化用以描述企业未来状态和发展的关键原则和模型以将业务愿景和战略转化成有效的企业变更的过程（Gartner）。\n就好比建一栋房子不是撸子袖子就去搬砖，需要有设计图纸，去决定房屋结构、构成部分、功能、空间关系等元素，而企业架构则是企业顶层设计的图纸。\n很多企业在进行信息化建设时，常常以技术为主导，把关注点放在当前问题的IT实现上，缺乏全局思考，与业务脱节，导致上线的新系统往往无法对业务提供有效支持，无法适应快速变化的需求；各系统间无法形成有效联动，也存在功能重复建设的情况。简单说来，就是管理层、IT人员和业务人员之间没有进行充分沟通并达成共识。\n数字化时代，“业务即IT，IT即业务”，已不能割裂来看业务与IT。在外部环境迅速变化、内部环境日益复杂的情况下，一个完备而科学的企业架构就显得极为重要。它可以在利益相关者（stakeholders）间、信息系统间、人与系统间搭建无障碍沟通的桥梁，保障各方拥有共同的理解与愿景。\n\n\n\n\n\n\n\n\n\n企业架构是承接企业业务战略与 IT战略之间的桥梁与标准接口，是企业信息化规划的核心。\n而企业架构框架，例如上面提到 TOGAF、Zachman、DoDAF 等，则是帮助企业全面、有序地去构建属于自己的企业架构的方法论和工具集。\n如何构建企业架构一来，并没有哪个企业架构框架适用于所有企业，企业需要根据自身情况选择合适的框架进行裁剪，借助框架进行企业架构的开发。TOGAF也说自己不是一个“one-size-fits-all”的框架。生搬硬套与全盘照抄是没有任何价值哒。\n二来，退一步说，企业架构定义不是一项简单工作，有一定的门槛，并不是处在所有发展阶段的所有企业都适合大力推行企业架构。对很多企业（特别是小微企业）来说，将重心放在方法论和工具的研究上不如老老实实地进行业务分析收效更快。就像在NBA球场上，战术体系的重要性不言而喻，然而现今很多年轻球队却是通过加快比赛节奏来赢球的，因为打磨体系太耗时间了。\n总之，企业框架很重要，但是不能盲目崇拜和过分依赖。\n目前较为主流和具备影响力的企业架构框架之一就是 TOGAF 啦。TOGAF 发展至今已有23年历史，2009年的市场占有率超过50%。TOGAF 在国外有 SAP、IBM 等公司在推动，在中国则于2009年由金蝶引入进行本地化和中文化工作。\n","slug":"2020-5-10-TOGAF","date":"2020-05-10T11:00:00.000Z","categories_index":"thinking","tags_index":"thinking","author_index":"Csuzhang"},{"id":"f7e8743372d74f41e88e20899613bd15","title":"6.828 ZhyOS在macOS下的环境配置-2020","content":"6.828 ZhyOS在macOS下的环境配置-2020\n\n\n\n\n\n\n\n\n本文主要介绍如何在macOS下配置mit 6.828 JOS的实验环境\n​    实习期做过一些业务之后，最直观的感受是做业务相对来说比较繁琐，每天疲于完成分配的需求，对个人成长来说不是特别大。和翔少一波交流后，还是想回归学校，利用余下不多的时间多打打基础，考虑抓抓基础以后往infrastructure方向发展。\n​    在进行JOS之前，在网上搜索关于JOS的开发环境，基本都是关于在ubuntu下的配置教程，很多博客和文章都提到“不是32位linux就不好配置，会浪费大量时间在配置环境”上之类的言论。奈何为囊中羞涩所困，在连续开了几个centOS后，本人OS X没有过多的存储资源可以使用，加上实在无法忍受开VMware恐怖的耗电量和发热量，尝试将开发环境移到macOS下。\n​    起初按照刘学长博客进行配置，但是出现一堆读不懂的error；简单碰壁后发现其实无比简单，在这里放上我的配置教程，过程非常简单可操作，希望能帮助到更多的coder完成这个项目。\n1. Tools we need配置环境之前，有两个工具是必须要进行配置的：\n\nHomebrew\n\nMacports\n建议大家直接Google，按照官网公开的方法进行配置即可～(需要在管理员模式下进行，否则会遇到很多Permission Denied的报错，通常难以解决，本菜🐔也被困扰很久)\n\n\n2. 运行JOS demo\nQEMU\n在Homebrew工具下，直接利用brew即可安装i386-jos-elf-gcc和i386-jos-elf-gdb\n\n\nbrew tap liudangyi&#x2F;i386-jos-elf-gcc &#x2F;&#x2F;添加第三方库\nbrew install i386-jos-elf-gcc i386-jos-elf-gdb\n\n\n\n\n官网克隆源码\n从mit课程官网得到6.828的git地址，发现从2018年后就未更新，所以我们用2018的代码实现\n\n\nmkdir ~&#x2F;6.828\ncd 6.828\ngit clone https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.828&#x2F;2018&#x2F;jos.git lab\n\n\n\n\nmake jos的boot loader和kernel\n\ncd .&#x2F;lab\nmake\n\n\n\n\n成功后及显示\n\n+ as kern&#x2F;entry.S\n+ cc kern&#x2F;entrypgdir.c\n+ cc kern&#x2F;init.c\n+ cc kern&#x2F;console.c\n+ cc kern&#x2F;monitor.c\n+ cc kern&#x2F;printf.c\n+ cc kern&#x2F;kdebug.c\n+ cc lib&#x2F;printfmt.c\n+ cc lib&#x2F;readline.c\n+ cc lib&#x2F;string.c\n+ ld obj&#x2F;kern&#x2F;kernel\ni386-jos-elf-ld: warning: section &#96;.bss&#39; type changed to PROGBITS\n+ as boot&#x2F;boot.S\n+ cc -Os boot&#x2F;main.c\n+ ld boot&#x2F;boot\nboot block is 382 bytes (max 510)\n+ mk obj&#x2F;kern&#x2F;kernel.img\n\n\n\n\n启动JOS qemu\n\nmake qemu\n\n此时即可成功启动JOS，enjoy～\n3. 持续关注​    正值疫情老虎徘徊，再加上工作需求和学业压力，今天先完成了相关环境的配置，后续会继续进行OS的开发和学习，计划在一个月内完成这6个Lab，自己学习的过程中也帮助大家踩踩坑，祝大家都能早日拿到心仪的offer～\n","slug":"2020-04-4-JOS","date":"2020-04-04T10:00:00.000Z","categories_index":"OS","tags_index":"OS","author_index":"Csuzhang"},{"id":"f12f50cba820b0109abbca457b92e39c","title":"Gtest单元测试框架","content":"引言文章中将先介绍单元测试的相关概念，然后引入Google的开源C++单元测试框架Gtest，对C++的各种单元测试场景提供完备的支持，最后通过编译、运行Gtest自带的一个测试样例，介绍如何在Unix/Linux下使用Gtest。\n单元测试说到单元测试，大家应该不会陌生。作为软件开发过程中最底层级别的测试环节，单元测试一般由开发人员自己完成。它的目的是隔离程序部件，并证明这些单个部件满足预期的功能。在静态程序分析、代码检视之后进行单元测试，可以帮助我们在开发过程的早期发现问题。好的测试具备以下特点：\n\n\n\n\n\n\n\n\n\n1.独立性\n一个测试用例应该是独立的，所谓“独立”，即该测试用例的测试结果不受其他测试的影响\n\n\n\n\n\n\n\n\n\n2.有效的组织架构，清晰的命名。\n各个测试用例针对不同的测试对象，而对单个测试对象而言，又可能有多个测试用例对应该对象的多个功能。好的习惯是把这些用例以层次结构的形式组织起来，并使用清晰的命名，使得我们通过阅读用例名称即可明了该用例的功能。\n\n\n\n\n\n\n\n\n\n3.可移植、可复用。\n像我们对程序平台性无关的苛刻要求一样，对于优秀的测试，我们也期望做到在不同的操作系统、编译器间进行方便地移植。\n\n\n\n\n\n\n\n\n\n4.当用例失败时，提供尽可能多的有效信息。\n毋庸置疑，提示信息越是清晰和全面，越方便我们定位问题、高效地找出程序中的bug。\n如今有不少测试框架帮助我们完成单元测试，像针对C++的有Google Test、CppUnit，针对C的有CUnit，针对Java的有JUnit，这些测试框架为我们实现独立、可移植、可复用、有组织的测试提供了条件，使我们能够专注于编写程序功能相关的测试代码。下面介绍Gtest的使用方法。\nGoogle C++单元测试框架Google C++单元测试框架（简称Gtest），可在多个平台上使用（包括Linux, Mac OS X, Windows, Cygwin和Symbian），它提供了丰富的断言、致命和非致命失败判断，能进行值参数化测试、类型参数化测试、“死亡测试”。Gtest是一个开源的项目，目前的代码发行版是1.6.0。\n","slug":"2020-3-2-gtest","date":"2020-03-02T12:00:00.000Z","categories_index":"Test","tags_index":"OS,Test","author_index":"Csuzhang"},{"id":"d24ba787beb7c57b8dde0e5cc960693e","title":"python实现常用测试模块","content":"用python实现常用测试模块python AES 加解密模块\n\n\n\n\n\n\n\n\nDefinition：\nAES：高级加密标准(Advanced Encryption Standard)是最常见的对称加密算法之一，微信小程序就是用合格加密算法。\n对称加密算法也就是加密和解密使用相同的密钥，具体的流程图如下图所示：\n\nAES使用分组密码，分组密码也就是将明文分成一组一组的，每组的长度相等，每次加密一组数据，知道将整个明文都加密完成。在AES标准规范中，分组长度只能是128位，也就是说，每个分组16个字节（每个字节8位）。密钥的长度可以使用128位、192位、256位等。\n密钥的长度不等，推荐加密的轮数也不相等。\n一般我们最常使用的就是AES-128，是密钥的长度为128位，加密轮数位10轮。\n\n\n\n\n\n\n\n\n\nAES加解密的流程中包括的主要步骤：\n明文分组 、字节代换、行位移、列混淆、轮密钥加\n\n\n\n\n\n\n\n\n\nAES算法代码实现：\nimport sys\nfrom Crypto.Cipher import AES\nfrom binascii import b2a_hex, a2b_hex\n\nclass prpcrypt():\n  \n\tdef __init__(self, key):\n\t\tself.key = key.encode('utf-8') self.mode = AES.MODE_CBC\n\t\t# 加密函数，如果 text 不是 16 的倍数【加密文本 text 必须为 16 的倍数!】，那就补足为 16 的 倍数\n    \n\tdef encrypt(self, text):\n\t\ttext = text.encode('utf-8')\n\t\t# 创建一个新的 AES 密码\n\t\t# key 为对称加密中使用的密钥，mode_CBC 是 AES 五种加密模式中的密码分组链接模式 \n    cryptor = AES.new(self.key, self.mode, self.key)\n# 这里密钥 key 长度必须为 16(AES-128)、24(AES-192)、或 32(AES-256)Bytes 长\n#度.目前 AES-128 足够用 length = 16\n\t\tcount = len(text)\n\t\tif (count % length != 0):\n\t\t\tadd = length - (count % length) \n    else:\n\t\t\tadd = 0\n\t\ttext = text + ('\\0' * add).encode('utf-8')\n\t\t# 真正的加密操作，使用初始化时的密钥加密数据\n\t\tself.ciphertext = cryptor.encrypt(text)\n# 因为 AES 加密时候得到的字符串不一定是 ascii 字符集的，输出到终端或者保存时候可能存\n在问题\n# 所以这里统一把加密后的字符串转化为 16 进制字符串 \n\t\treturn b2a_hex(self.ciphertext)\n\n# 解密后，去掉补足的空格用 strip() 去掉 \n\tdef decrypt(self, text):\n\t\tcryptor = AES.new(self.key, self.mode, self.key)\n    plain_text = cryptor.decrypt(a2b_hex(text))\n# return plain_text.rstrip('\\0')\n\t\treturn bytes.decode(plain_text).rstrip('\\0')\n\nif __name__ == '__main__':\n\npc = prpcrypt('keyskeyskeyskeys') # 初始化密钥\ne = pc.encrypt(\"0123456789ABCDEF\") # 对输入明文进行加密 \nd = pc.decrypt(e) # 解密密文操作\nprint(e, d)\ne = pc.encrypt(\"00000000000000000000000000\")\nd = pc.decrypt(e)\nprint(e, d)\n下面我们来看下代码的运行结果：\n\npython unittest 单元测试模块\n\n\n\n\n\n\n\n\nunittest 是 python 的一个基础常用的单元测试框架，\n便于我们编写测试用例以及测试执行。其中中最核心的四个概念是:\ntest case\n\ntest suite\n\ntest runner\n\ntest fixture\n\n\nunittest 进行单元测试的流程：\n\n写好 TestCase，然后由 TestLoader 加载 TestCase 到 TestSuite\n然后由 TextTestRunner 来运行 TestSuite，运行的结果保存在 TextTestResult 中\n我们通过命令行或者 unittest.main()执行时，main 会调用 TextTestRunner 中的 run 来执行，或者我们可以直接通过 TextTestRunner 来执行用 例。\n\n一个 class 继承 unittest.TestCase 即是一个 TestCase，其中以 test 开头的方法 在 load 时被加载为一个真正的 TestCase。\n在 TestRunner 中的 verbosity 参数可以控制执行结果的输出，0 是简单报告、1 是一般报告、2 是详细报告。\n下面完成一次基本的 unittest 单元测试：\n# 准备好待测函数\ndef add(a, b): \n  return a+b\ndef minus(a, b):\n  return a-b\ndef multi(a, b):\n  return a*b\ndef divide(a, b):\n  return a/b\n\n然后写出待测函数的测试方法：\nimport unittest\nfrom mathfunc import *\n\nclass TestMathFunc(unittest.TestCase): \n  \"\"\"Test mathfuc.py\"\"\"\n\tdef setUp(cls):\n\t\tprint(\"do something before test.Prepare environment.\")\n\n  def tearDown(cls):\n\t\tprint(\"do something after test.Clean up.\")\n\n  def test_add(self):\n\t\t\"\"\"Test method add(a, b)\"\"\" \n    print(\"add\")\n\t\tself.assertEqual(3, add(1, 2)) \n    self.assertNotEqual(3, add(2, 2))\n\n  def test_minus(self):\n\t\t\"\"\"Test method minus(a, b)\"\"\" \n\t\tprint(\"minus\") \n    self.assertEqual(1, minus(3, 2))\n\n  def test_multi(self):\n\t\t\"\"\"Test method multi(a, b)\"\"\" \n    print(\"multi\") \n    self.assertEqual(6, multi(2, 3))\n\n  def test_divide(self):\n\t\t\"\"\"Test method divide(a, b)\"\"\"\n    print(\"divide\")\n\t\tself.assertEqual(2, divide(6, 3)) \n    self.assertEqual(2.5, divide(5, 2))\n    \nif __name__ == '__main__': \n  unittest.main()\n\n以上代码已经可以完成一次简单的单元测试了，但是还无法按照指定的顺序 来执行测试用例。因此我们这里使用 suite 来控制每个 case 的先后执行顺序：同 时，如果同时有多个测试文件，我们也可以通过 suite 来控制他们进行一起执行。\n# -*- coding: utf-8 -*-\nimport unittest\nfrom test_mathfunc import TestMathFunc \nfrom HTMLTestRunner import HTMLTestRunner\n\nif __name__ == '__main__':\nsuite = unittest.TestSuite() suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc)) \nwith open('UnittestTextReport.txt', 'a') as f:\nrunner = unittest.TextTestRunner(stream=f, verbosity=2)\nrunner.run(suite)\n\n然后我们试着运行，可以看到运行结果如下：\n\n\n\n\n\n\n\n\n\n\n如果出现有 ok 的记号，则表示本次测试的结果为成功;如果出现 fail，则表 示测试结果出现问题，这时我们就需要寻找问题，看看测试结果问题在哪里。\npython assert 断言对于断言，官方有一段官方的解释:Assert statements are a convenient way toinsert debugging assertions into a program，其作用就是类似于我们 debug 的工具，\n一般的用法是:\nassert condition\n\n用来让程序测试这个 condition，如果 condition 为 false，那么 raise 一个AssertionError 出来。逻辑上等同于:\nif not condition:\n    raise AssertionError()\n\n我们来简单做一个小小的断言测试:\nassert 1==2, \"以下结果出现断言\"\n\n结果如下：\n\npython pyserial 串口模块pyserial 模块封装了对串口的访问。在支持的平台上有统一的接口，通过 python属性访问串口设置。支持不同的字节大小、停止位、校验位和流控设置。 \n在串口的配置中，有以下一些比较重要的属性需要我们了解：波特率、数据位、停止位、校验位、字节大小、读写超时设置等。 下面我们来看下对于串口的设置方法：\nimport sys\nimport glob\nimport time\nimport serial\nimport serial.tools.list_ports\n8\ndef serial_ports():\n\"\"\" Lists serial port names\n       :raises EnvironmentError:\n          On unsupported or unknown platforms\n       :returns:\n          A list of the serial ports available on the system\n\"\"\"\n# 如果是 windows 平台的系统，对应的串口号形式 if sys.platform.startswith('win'):\nports = ['COM%s' % (i + 1) for i in range(256)]\n# 如果是 Linux 平台的系统，对应的串口号形式\nelif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):\n# this excludes your current terminal \"/dev/tty\"\nports = glob.glob('/dev/tty[A-Za-z]*') # 如果是 OS X 的系统，对应的串口号形式\nelif sys.platform.startswith('darwin'):\nports = glob.glob('/dev/tty.*') else:\nraise EnvironmentError('Unsupported platform') result = []\n# 可以通过 Serial 函数对每一个串口进行控制其操作 for port in ports:\ntry:\ns = serial.Serial(port) s.close() result.append(port)\nexcept (OSError, serial.SerialException): pass\nreturn result\n# 这句命令可以在终端打印出所有的串口设备\nprint(list(serial.tools.list_ports.comports()))\nif __name__ == '__main__': print(serial_ports())\n\n下面看下我电脑上打印出来的相关串口号，可以看到一共有 3 个，表示的是每个 串口分配到的地址：\n\n","slug":"2020-2-25-pytest","date":"2020-02-25T15:00:00.000Z","categories_index":"Test","tags_index":"OS,Test","author_index":"Csuzhang"},{"id":"faf57fc67eb65f85eddb08e39325fc44","title":"Shell脚本2小时速学","content":"Shell简介Shell 是一个用 C 语言编写的程序，它是用户使用Linux的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。\n而Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。\n创建第一个Shell脚本打开文本编辑器(我用的是macOS，可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。\n输入一些代码，第一行一般是这样：\n#!&#x2F;bin&#x2F;bash\necho &quot;Hello World !&quot;\n#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。\n运行第一个Shell脚本(1/2)\n\n\n\n\n\n\n\n\n1、作为可执行程序\n将上面的代码保存为 test.sh，并 cd 到相应目录：\nchmod +x .&#x2F;test.sh  #使脚本具有执行权限\n.&#x2F;test.sh  #执行脚本\n注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。\n\n\n\n\n\n\n\n\n\n2、作为解释器参数\n这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：\n&#x2F;bin&#x2F;sh test.sh\n&#x2F;bin&#x2F;php test.php\n\n定义Shell变量定义变量时，变量名不加美元符号（$，PHP语言中变量需要）\n注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\n\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n中间不能有空格，可以使用下划线（_）。\n不能使用标点符号。\n不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n\n\n\n\n\n\n\n\n\n除了显式地直接赋值，还可以用语句给变量赋值，如：\nfor file in &#96;ls &#x2F;etc&#96;\n或\nfor file in $(ls &#x2F;etc)\n以上语句将 /etc 下目录的文件名循环出来。\n使用Shell变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\nyour_name=\"qinjx\"\necho $your_name\necho $&#123;your_name&#125;\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\nfor skill in Ada Coffe Action Java; do\n    echo \"I am good at $&#123;skill&#125;Script\"\ndone\n\n如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n强烈推荐给所有变量加上花括号，这是个好的编程习惯。\n\n\n\n\n\n\n\n\n\n已定义的变量，可以被重新定义\n","slug":"2020-2-21-shell","date":"2020-02-21T13:00:00.000Z","categories_index":"Test","tags_index":"OS,Test,shell","author_index":"Csuzhang"},{"id":"922a078e310ed087c60322a7fd27c1cb","title":"API接口测试入门","content":"API接口测试入门\n\n\n\n\n\n\n\n\nAPI是Application Programming Interface的简写，我们又把接口测试叫做API测试，主要用于实现多个系统之间或系统内部模块之间的通信和数据交换的能力。\n1.接口定义接口测试主要用于系统与系统之间以及内部各个子系统或模块之间的交互点。定义特定的交互点，然后通过这些交互点，以及一些特殊的规则也就是协议，来进行数据之间的交互。前后端之间配合工作，就是其中一方定义实现接口，另一方来调用接口，以实现预期功能。\n举个简单的例子，我们在开车踩油门时，并不需要知道油门内部的零线/火线以及具体的电路结构，因为汽车制造商已经将给油的一系列操作全部封装成了油门这样一个接口，用户只要傻瓜式地进行踩油门的操作就可以让汽车实现加速。\n2.接口分类\n\n\n\n\n\n\n\n\nWebService和HTTP\n（1）WebService接口走soap协议，请求报文和返回报文都是xml格式，通过SoapUI工具进行测试；\n（2）HTTP API接口走HTTP协议，通过路径来区分调用的方法，请求报文入参有多种形式，返回报文一般为json串，最常见的是get和post方法。\n3.接口测试必要性（1）效率上：现在系统的复杂性与日俱增，传统测试方法人工成本过高且效率低下，而接口测试比较容易实现自动化集成，减少人工成本与时间，缩短测试周期；\n（2）安全上：前后端架构分离，只依靠前端进行测试已经完全不能满足系统安全要求，绕过前面实在太容易，需要后端同样进行控制，在这种情况下就需要从接口层面验证。\n4.接口测试原理通过程序模拟客户端向服务器发送请求报文，服务器接收请求报文后对报文做处理并向客户端返回应答，客户端再接收应答的一个过程。\n5.接口文档关键部分接口说明\n调用的url\n请求方法（get、post）\n请求参数，参数类型、请求参数说明\n返回参数说明\n返回示例\n6.接口测试分类（1）功能测试：由于是针对基本业务功能进行测试，这部分是两种测试重合度最高的一块，开发同学通常所指的也主要是这部分的内容。测试覆盖：业务流程，参数类型、可选项等。\n（2）边界分析测试：在基本功能测试的基础上考虑输入输出的边界条件。相对来说接口可以覆盖的范围很广，同样的，接口出现问题的概率也更高。测试覆盖：边界值、特殊字符等。\n（3）性能测试：接口性能主要关注接口响应时间、并发、服务端资源的使用情况等。越靠近底层，对于系统的性能优化越有利。测试覆盖：并发数、吞吐量、tps等\n7.接口测试工具Postman，jmeter，soupUI等测试工具。\n测试用例基本概念拓展\n\n\n\n\n\n\n\n\n简单来说，测试用例就是一个文档，描述输入、输出、动作、时间等，其目的是确定应用程序的某个特性是否正常工作，并且达到程序所设计的期望结果。\n测试用例的作用\n有效性\n\n避免穷举测试，选取代表性的测试数据进行测试，节省时间和资源，提高测试效率\n\n避免测试的盲目性\n\n开始测试之前设计好测试用例，避免盲目测试，使得重点突出、目的明确\n\n可维护性\n\n软件版本更新后，只需部分修正测试用例即可继续开展，降低工作强度，缩短项目周期\n\n可复用性\n\n项目功能的模块化，使软件易于开发，使得测试过程事半功倍\n\n可评估性\n\n程序代码的质量的量化标准应该用测试用例的通过率和测试输出软件缺陷的数目来进行评估\n\n可管理性\n\n测试用例是测试人员的重要参考依据，也可以作为检验测试进度、测试工作量的因素，来对测试工作进行有效管理\n测试用例的设计通常由经验丰富的测试人员设计测试用例，经验较少的人员从执行测试用例开始进行，随着经验和技术的积累，再逐渐开始参与测试用例的设计工作。\ntip1.测试设计说明类似开发人员有项目开发功能书一样，测试人员也要有说明书来指导测试人员如何设计测试用例，包括但不限于：被测特性、测试所用的方法、测试准则等。\n\n标识符\n\n被测特性\n\n方法\n\n测试用例信息\n\n通过/失败规则\n\n\ntip2.测试用例编写\n用例的编号\n\n由测试引用的唯一标识符，便于查找测试用例，也便于用例的追踪和管理\n\n测试标题\n\n对测试用例的描述，清楚表达用例的相关用途等\n\n测试项\n\n测试用例应该具体详细的描述所测试项的详细特征，更加详细具体\n\n测试环境要求\n\n该测试用例执行的外部条件，软硬件具体指标和测试工具等\n\n特殊要求\n\n对环境的特殊需求，如所需设备型号、对防火墙等的特殊设置\n\n测试输入说明\n\n提供测试执行中的各种输入条件。根据需求中的输入条件，确定测试用例的输入。\n\n操作步骤\n\n提供测试执行的过程步骤，对于复杂的用例，应该分为几个步骤分别完成测试。\n\n预期结果\n\n提供测试执行的预期结果，预期结果应该根据软件需求中的输出得出。如实际结果与预期结果不符合，则测试不通过。\n\n测试用例之间的关联\n\n用来标示该测试用例和其他测试用例之间的依赖关系。在实际测试中，很多测试用例并不是单独存在的，而是可能存在 某种相互依赖关系。\n\n测试用例设计人员和测试人员\n\n测试优先级\n\n\n一般分为0～4的一共5个等级，通过优先级来标注出软件测试的重点和先后顺序。\n测试用例的分类和阶段\n\n\n测试阶段\n测试类型\n执行人员\n\n\n\n单元测试\n模块功能测试、部分接口测试、覆盖测试、路径测试\n开发与测试结合\n\n\n集成测试\n接口测试、路径测试、部分功能测试\n开发与测试结合或测试\n\n\n系统测试\n功能测试、兼容性测试、性能测试、用户界面测试、安全性测试、强度测试、可靠性测试\n测试人员\n\n\n验收测试\n对于实际项目基本同上、包含文档测试\n测试人员或包含用户\n\n\n","slug":"2020-1-20-API-test-learning","date":"2020-01-20T12:00:00.000Z","categories_index":"Test","tags_index":"OS,Test","author_index":"Csuzhang"},{"id":"f00e3ec5c280760af654d0694cfedbc0","title":"串口通信相关参数","content":"串行通信定义串行通信是计算机通信的主要方式之一，起到主机与外设之间以及主机之间的数据传输作用，因此串行通信的接口上计算机系统中的常用接口。\n串行通信是指通信双方按位进行，遵守时序的一种通信方式。数据按位依次传输，每位数据占据固定的时间长度，即可使用少数几条通信线路就可以完成系统之间的信息交换。串行总线通信的显著特点是：通信线路少，布线简便易行，施工方便，系统间协议自由度以及灵活度较高。\n分类\n\n\n\n\n\n\n\n\n同步通信\n同步通信是一种连续串行传输数据的通信方式，一次传输只传送一帧信息，其中通常包含若干个数据字符。\n这里的信息帧由同步字符、数据字符和校验字符组成，同步字符用于确定数据字符的开始，一半是固定的开头同步字；数据字符在同步字符之后，由所需传输的数据块的长度决定；校验字符有1-2个，用于接收端对接收到的字符序列进行正确性的校验，常用奇偶校验法。\n同步通信是按位传输。\n\n\n\n\n\n\n\n\n\n  异步通信\n异步通信在发送字符时，所发送的字符之间的时间间隔是任意的，接收端要时刻做好接受的准备。因为能在任一时刻发送字符，所以必须在每一个字符的开始和结束的地方加上标志(开始位，停止位)，因此异步通信的好处是通信设备简单便宜，但是传输效率低下。\n","slug":"2020-1-14-serial-communication","date":"2020-01-14T06:00:00.000Z","categories_index":"OS","tags_index":"OS,web,Test","author_index":"Csuzhang"}]