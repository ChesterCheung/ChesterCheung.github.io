[{"id":"874828a6f7134332a608ce3bbd85a232","title":"理解区分IaaS、SaaS、PaaS的含义和区别","content":"相信你一定听说过IaaS、SaaS、PaaS等概念，这些都是云计算中的三个高大上的概念，但这几个术语其实并不好理解。不过，我们可以利用吃披萨🍕来给大家类比这几个概念的理解。\n类比披萨店吃披萨首先，一个吃货怎样才能吃到披萨呢？有以下几种方式：\n\n在家自己做\n\n但是你要准备的东西很多，材料、工具、烤箱……还需要经过发面、做面团、进烤箱等工序才能完成\n\n从披萨店买做好的披萨\n\n你只需要去披萨店买成品披萨，回家烘焙号了就可以在自己的餐桌上吃，和在家自己做不一样，你只需要一个pizza提供商\n\n打电话叫外卖\n\n打个电话把披萨叫到家中，pizza就送到家中，但你需要自己准备桌椅、苏打水等\n\n直接去披萨店吃\n\n你什么都不需要准备，连餐桌都是pizza店的\n下图就是我们可以吃到披萨的总结：\n\n企业端技术分层现在我们从披萨店变成一家超大型技术公司，根本不需要别人为我们提供服务，你拥有基础设施、应用等等一切，可以分为三层：基础设施infrastructure、平台platform、应用application\n\n这张图其实就是云计算的三个分层：基础设施在最底层、平台在中间层、软件应用在顶层，分别是：Infrastructure-as-a-Service(IaaS)，Platform-as-a-Service(PaaS)，Software-as-a-Service(SaaS)，别的一些“软的”层可以在这些层的基础上添加。\n\n如果你的公司什么都有，现在所处的状态叫本地部署，就想自己在家做披萨一样。你需要购买服务器以及其他硬件设备来控制本地应用，让你的业务代码运行起来，这就叫本地部署。\n\n假如有天boss想明白了，只是为了吃到pizza，没必要所有流程都自己完成。于是，他准备考虑一家云服务提供商，这个云服务提供商能提供哪些服务呢？\n\n\n","slug":"2020-6-10-SaaS","date":"2020-06-10T12:00:00.000Z","categories_index":"thinking","tags_index":"thinking","author_index":"Csuzhang"},{"id":"8483753522c9d846e8ac4a720d8703bb","title":"TOGAF企业架构体系","content":"TOGAF定义TOGAF 即 The Open Group Architecture Framework （开放组体系结构框架），是由致力于技术标准制定和推广的非盈利组织 The Open Group 制定的用于开发企业架构（Enterprise Architecture）的一套方法和工具。\n在介绍 TOGAF 之前，今天先来聊聊企业架构。企业架构由IT架构发展而来。所以在一些定义中，会把企业架构简单定义为企业信息系统建设的规划。\n\n\n\n\n\n\n\n\n\n上世纪七十年代美国军方想要建立一个牛X的系统来管理通讯指挥作战的所有相关资源，建立这个系统的方法后来形成理论并于2003年发展成 DoDAF （美国国防部体系架构框架）。在那之前，民间已经发展出好几个框架雏形。其中，1987美国人 John Zachman 发表论文首次提出了“信息系统架构框架”的概念（后改称“企业架构框架”），奠定了企业架构的理论基础。\n但其实现在我们讲的企业架构，一般包括业务架构（流程、组织）、应用架构（应用、服务）、数据架构（数据、信息）和技术架构（硬件、网络）这几方面内容。\n\n企业架构组成根据 TOGAF 的定义，企业是具有一系列共同目标的组织的集合。而企业架构则是为了有效地实现这一系列目标，去定义企业的结构和运作模式的概念蓝图（SearchCIO），是构成企业的所有关键元素和其关系的综合描述（Zachman），是通过创建、沟通和优化用以描述企业未来状态和发展的关键原则和模型以将业务愿景和战略转化成有效的企业变更的过程（Gartner）。\n就好比建一栋房子不是撸子袖子就去搬砖，需要有设计图纸，去决定房屋结构、构成部分、功能、空间关系等元素，而企业架构则是企业顶层设计的图纸。\n很多企业在进行信息化建设时，常常以技术为主导，把关注点放在当前问题的IT实现上，缺乏全局思考，与业务脱节，导致上线的新系统往往无法对业务提供有效支持，无法适应快速变化的需求；各系统间无法形成有效联动，也存在功能重复建设的情况。简单说来，就是管理层、IT人员和业务人员之间没有进行充分沟通并达成共识。\n数字化时代，“业务即IT，IT即业务”，已不能割裂来看业务与IT。在外部环境迅速变化、内部环境日益复杂的情况下，一个完备而科学的企业架构就显得极为重要。它可以在利益相关者（stakeholders）间、信息系统间、人与系统间搭建无障碍沟通的桥梁，保障各方拥有共同的理解与愿景。\n\n\n\n\n\n\n\n\n\n企业架构是承接企业业务战略与 IT战略之间的桥梁与标准接口，是企业信息化规划的核心。\n而企业架构框架，例如上面提到 TOGAF、Zachman、DoDAF 等，则是帮助企业全面、有序地去构建属于自己的企业架构的方法论和工具集。\n如何构建企业架构一来，并没有哪个企业架构框架适用于所有企业，企业需要根据自身情况选择合适的框架进行裁剪，借助框架进行企业架构的开发。TOGAF也说自己不是一个“one-size-fits-all”的框架。生搬硬套与全盘照抄是没有任何价值哒。\n二来，退一步说，企业架构定义不是一项简单工作，有一定的门槛，并不是处在所有发展阶段的所有企业都适合大力推行企业架构。对很多企业（特别是小微企业）来说，将重心放在方法论和工具的研究上不如老老实实地进行业务分析收效更快。就像在NBA球场上，战术体系的重要性不言而喻，然而现今很多年轻球队却是通过加快比赛节奏来赢球的，因为打磨体系太耗时间了。\n总之，企业框架很重要，但是不能盲目崇拜和过分依赖。\n目前较为主流和具备影响力的企业架构框架之一就是 TOGAF 啦。TOGAF 发展至今已有23年历史，2009年的市场占有率超过50%。TOGAF 在国外有 SAP、IBM 等公司在推动，在中国则于2009年由金蝶引入进行本地化和中文化工作。\n","slug":"2020-5-10-TOGAF","date":"2020-05-10T11:00:00.000Z","categories_index":"thinking","tags_index":"thinking","author_index":"Csuzhang"},{"id":"6f5ea625869961c502c50cec5703ac96","title":"手握日月摘星辰，更藉浊酒祭风尘","content":"——2019不负盛世年华，2020拼命奋发有为今天是2019年12月1日，距离这一年的结束只剩下了最后一个月的韶光，回首2019年的所遇所为、所闻所感，有着颇深的感悟，也正巧受到山西天美集团张永芬姐姐的邀请，和来长沙团建的哥哥姐姐们一起吃了晚饭，刚刚结束了狼人杀局，睡不着觉之间突然开始思考，在酒店写下这一年时间的感悟。\n首先这一年的开端是个不良的开始。由于2018的残留感情问题，2019的前几个月仍然徘徊在分手的边缘，就是那种知道早晚会分还在苦苦坚持的状态，现在想想真的佩服当时傻傻的自己，过年都自己一个人大半夜喝着闷酒。\n直到3月多彻底分道扬镳才从那种状态中醒悟过来。这个其实还要感谢胡总，在那段感情挣扎的期间，每天帮我找各种项目做，各种实验室进，各种大佬一起蹭饭，使挣扎于感情无法脱身的我明白了自己想追求的是什么。也许那段时间是我这一年中最充实最踏实的时光。\n从一个个小的demo做起，画图板、五子棋、飞机大战、图像处理、美颜相机，再到后来的Hadoop、Kafka、Zookeeper、Linux0.11等等……不到2个月的时间里就实现了代码真正的入门，我觉得这才是蓝杰带给我的最有意义和价值的收获之一：学会学习写代码的能力。\n\n然后2019中间那段时间，一部分时间是在实验室度过的，另外一段时间是在美国密苏里州哥伦比亚大学度过的。实验室从张校长的“英特尔透明计算实验室”到陈老师的“智能驾驶实验室”，学到了不少、看到了不少，算是部分体验到了做研究生的感觉；\n在暑研期间从北京飞到远在地球另一边的美利坚，在壮阔无垠的米国中部地区体验到别样的异国风情。这段经历极大的拓宽了视野范围，让我亲身感受到了去国外实验室做科研是一种怎样的体验，对我日后选择道路起到了非常重要的作用，也让我开始觉得每天闷在实验室搞研究不适合我。\n\n\n感谢在此期间各位大佬学长/师兄们给予我的诸多指点，这里就不再一一列举。多亏了学长的开导，从最开始的畏畏缩缩畏首畏尾，到现在的不问三七二十一先干再说，我找到了属于自己的方向，明白了自己短期内未来想走的路。这段时间，使我蜕变了。\n2019年走过了很多城市，造访了许多地区：太原、长沙、西安、北京、上海、广州、济南、杭州、昆明、香格里拉、西双版纳、大理、丽江、达拉斯、圣路易斯、哥伦比亚、堪萨斯城等城市；\n2019年参观过互联网公司，逛了很多大厂：百度、滴滴、微软、IBM、谷歌、网易、阿里巴巴、商汤、远大等众多互联网公司；\n\n\n\n\n2019年结识到不少有趣的人，睁眼看了世界：青年创业者、大厂开发工程师、offer收割机、亿万富翁、环游世界者、热衷公益者、两院院士等；\n\n\n\n\n\n2019年有过坎坷、有过挫折、有过徘徊、有过迷茫、有过悲恸欲绝、也有过“蓦然回首，那人却在灯火阑珊处”的欣喜。\n……\n\n2018后半年，我完全没有进入大学生活的状态，完完整整的活在高中的回忆中，算是搞对象荒废掉了半年的时间；2019前半年，我实现了完美的华丽转身，逆境中完成了阶段性逆袭，不仅找到了未来的路而且收获颇丰。即使成绩上并没有太大的建树，但没有荒废掉自己这段宝贵时光。\n\n2019也是参加各种比赛的一年，刚进入大学的时候，想参加各种竞赛但苦于没有队友、没有路子，对各种情形都不了解，再加上自己的能力不足，所以对任何比赛都挺无感的。\n但2019一年，我经过前辈们的指点，利用一年时间参加了许许多多的各种比赛，在团队中担任的角色也在pm、dev、leader、speaker之间来回切换，对整体项目流程已经烂熟于心。下面简单列举下这一年时间参加过的比赛，不管结果如何，都是一段宝贵的经历：\n\n\n\n\n\n\n\n\n\n\n2019年中国高校智能机器人创意大赛\n2019年上半年中南大学智能互联大赛\n2019年全国大学生创新创业大赛(到校赛)\n2019年中国互联网+大学生创新创业大赛(到校赛)\n2019年华中HackFun黑客马拉松\n2019年清华大学GSF Innovation Accelerator创新孵化器(到决赛，3rd)\nKaggle Competition 未来预测 &amp; 泰坦尼克号预测\n湖南省柳枝行动2019年9月(到终审)\n京东5G应用设计创意大赛\n2019年上海XdHack黑客马拉松\n2019年湖南省大学生智能导航科技创新大赛(到省赛，3rd)\n2019年全国大学生软件创新大赛(到国赛)\n\n到现在仍然在不停的充实完善自己，可以看下我的自我介绍就能知道啦：\nAbout me\n虽然参加很多，但是失败占到了大多数，很少有能走到最后的项目，但是在这个过程中收获了很多，俗称“面向过程”的学习。跟着几个学长也搞过项目，大多数都是自己想出idea，然后组建team，完善创意文档，完成项目实现，现场陈述答辩，每个过程都给了我非常好的经历和体验。虽说少部分项目过程中难免有划水的嫌疑，但是凭良心问还是基本上尽到了自己的全力，也因此结交到不少志同道合的岳麓青年，大家聚首麓山脚下，凭江共饮，何其快哉！\n\n2019也圆了高中时期的创业梦——自己开一家公司运营。于是，决定空余时间玩点和别人不一样的打法，和几个学长们一起合伙探索互联网人才服务领域的新模式，2018年底组建“这很江湖工作室”，2019年7月工作室成功升级成为“长沙派荐网络科技有限公司”.\n在伙伴们的信任下，我有幸担任了公司的法人代表，作为团队CTO积极开拓线上业务。到现在为止，已经成功服务梦洁、理诚、简聘等20+中小型公司，为500+学生提供了个人发展方向指点，拥有1000+忠实线上粉丝，这个创业过程更是让我获益匪浅。\n\n9月开学初想找实习试试水，于是写简历、投简历、一面、二面、HR面，成功拿到了滴滴出行的offer，应该算是我们这边圈子内今年第一个拿到offer的大二学生；到后来快到年底差不多11月份左右，我准备正式找寒假实习，继续每天刷题面试，大约不到两周时间吧，成功拿到了商汤科技、京东等公司offer，实现了阶段性小目标。\n\n\n最后自己总结这一年的时光，微醉中写下了内心的感悟：手握日月摘星辰，更藉浊酒祭风尘。\n\n希望自己不负青春、不负韶华，以梦为马、奋发有为！祝愿即将到来的2020年一切顺利，能得到想得到的一切，收获该收获的喜悦！\n","slug":"2019-12-1-2019Summary","date":"2019-12-01T12:00:00.000Z","categories_index":"thinking","tags_index":"thinking","author_index":"Csuzhang"},{"id":"f7e8743372d74f41e88e20899613bd15","title":"6.828 ZhyOS在macOS下的环境配置-2020","content":"6.828 ZhyOS在macOS下的环境配置-2020\n\n\n\n\n\n\n\n\n本文主要介绍如何在macOS下配置mit 6.828 JOS的实验环境\n​    实习期做过一些业务之后，最直观的感受是做业务相对来说比较繁琐，每天疲于完成分配的需求，对个人成长来说不是特别大。和翔少一波交流后，还是想回归学校，利用余下不多的时间多打打基础，考虑抓抓基础以后往infrastructure方向发展。\n​    在进行JOS之前，在网上搜索关于JOS的开发环境，基本都是关于在ubuntu下的配置教程，很多博客和文章都提到“不是32位linux就不好配置，会浪费大量时间在配置环境”上之类的言论。奈何为囊中羞涩所困，在连续开了几个centOS后，本人OS X没有过多的存储资源可以使用，加上实在无法忍受开VMware恐怖的耗电量和发热量，尝试将开发环境移到macOS下。\n​    起初按照刘学长博客进行配置，但是出现一堆读不懂的error；简单碰壁后发现其实无比简单，在这里放上我的配置教程，过程非常简单可操作，希望能帮助到更多的coder完成这个项目。\n1. Tools we need配置环境之前，有两个工具是必须要进行配置的：\n\nHomebrew\n\nMacports\n建议大家直接Google，按照官网公开的方法进行配置即可～(需要在管理员模式下进行，否则会遇到很多Permission Denied的报错，通常难以解决，本菜🐔也被困扰很久)\n\n\n2. 运行JOS demo\nQEMU\n在Homebrew工具下，直接利用brew即可安装i386-jos-elf-gcc和i386-jos-elf-gdb\n\n\nbrew tap liudangyi&#x2F;i386-jos-elf-gcc &#x2F;&#x2F;添加第三方库\nbrew install i386-jos-elf-gcc i386-jos-elf-gdb\n\n\n\n\n官网克隆源码\n从mit课程官网得到6.828的git地址，发现从2018年后就未更新，所以我们用2018的代码实现\n\n\nmkdir ~&#x2F;6.828\ncd 6.828\ngit clone https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.828&#x2F;2018&#x2F;jos.git lab\n\n\n\n\nmake jos的boot loader和kernel\n\ncd .&#x2F;lab\nmake\n\n\n\n\n成功后及显示\n\n+ as kern&#x2F;entry.S\n+ cc kern&#x2F;entrypgdir.c\n+ cc kern&#x2F;init.c\n+ cc kern&#x2F;console.c\n+ cc kern&#x2F;monitor.c\n+ cc kern&#x2F;printf.c\n+ cc kern&#x2F;kdebug.c\n+ cc lib&#x2F;printfmt.c\n+ cc lib&#x2F;readline.c\n+ cc lib&#x2F;string.c\n+ ld obj&#x2F;kern&#x2F;kernel\ni386-jos-elf-ld: warning: section &#96;.bss&#39; type changed to PROGBITS\n+ as boot&#x2F;boot.S\n+ cc -Os boot&#x2F;main.c\n+ ld boot&#x2F;boot\nboot block is 382 bytes (max 510)\n+ mk obj&#x2F;kern&#x2F;kernel.img\n\n\n\n\n启动JOS qemu\n\nmake qemu\n\n此时即可成功启动JOS，enjoy～\n3. 持续关注​    正值疫情老虎徘徊，再加上工作需求和学业压力，今天先完成了相关环境的配置，后续会继续进行OS的开发和学习，计划在一个月内完成这6个Lab，自己学习的过程中也帮助大家踩踩坑，祝大家都能早日拿到心仪的offer～\n","slug":"2020-04-4-JOS","date":"2020-04-04T10:00:00.000Z","categories_index":"OS","tags_index":"OS","author_index":"Csuzhang"},{"id":"d24ba787beb7c57b8dde0e5cc960693e","title":"python实现常用测试模块","content":"用python实现常用测试模块python AES 加解密模块\n\n\n\n\n\n\n\n\nDefinition：\nAES：高级加密标准(Advanced Encryption Standard)是最常见的对称加密算法之一，微信小程序就是用合格加密算法。\n对称加密算法也就是加密和解密使用相同的密钥，具体的流程图如下图所示：\n\nAES使用分组密码，分组密码也就是将明文分成一组一组的，每组的长度相等，每次加密一组数据，知道将整个明文都加密完成。在AES标准规范中，分组长度只能是128位，也就是说，每个分组16个字节（每个字节8位）。密钥的长度可以使用128位、192位、256位等。\n密钥的长度不等，推荐加密的轮数也不相等。\n一般我们最常使用的就是AES-128，是密钥的长度为128位，加密轮数位10轮。\n\n\n\n\n\n\n\n\n\nAES加解密的流程中包括的主要步骤：\n明文分组 、字节代换、行位移、列混淆、轮密钥加\n\n\n\n\n\n\n\n\n\nAES算法代码实现：\nimport sys\nfrom Crypto.Cipher import AES\nfrom binascii import b2a_hex, a2b_hex\n\nclass prpcrypt():\n  \n\tdef __init__(self, key):\n\t\tself.key = key.encode('utf-8') self.mode = AES.MODE_CBC\n\t\t# 加密函数，如果 text 不是 16 的倍数【加密文本 text 必须为 16 的倍数!】，那就补足为 16 的 倍数\n    \n\tdef encrypt(self, text):\n\t\ttext = text.encode('utf-8')\n\t\t# 创建一个新的 AES 密码\n\t\t# key 为对称加密中使用的密钥，mode_CBC 是 AES 五种加密模式中的密码分组链接模式 \n    cryptor = AES.new(self.key, self.mode, self.key)\n# 这里密钥 key 长度必须为 16(AES-128)、24(AES-192)、或 32(AES-256)Bytes 长\n#度.目前 AES-128 足够用 length = 16\n\t\tcount = len(text)\n\t\tif (count % length != 0):\n\t\t\tadd = length - (count % length) \n    else:\n\t\t\tadd = 0\n\t\ttext = text + ('\\0' * add).encode('utf-8')\n\t\t# 真正的加密操作，使用初始化时的密钥加密数据\n\t\tself.ciphertext = cryptor.encrypt(text)\n# 因为 AES 加密时候得到的字符串不一定是 ascii 字符集的，输出到终端或者保存时候可能存\n在问题\n# 所以这里统一把加密后的字符串转化为 16 进制字符串 \n\t\treturn b2a_hex(self.ciphertext)\n\n# 解密后，去掉补足的空格用 strip() 去掉 \n\tdef decrypt(self, text):\n\t\tcryptor = AES.new(self.key, self.mode, self.key)\n    plain_text = cryptor.decrypt(a2b_hex(text))\n# return plain_text.rstrip('\\0')\n\t\treturn bytes.decode(plain_text).rstrip('\\0')\n\nif __name__ == '__main__':\n\npc = prpcrypt('keyskeyskeyskeys') # 初始化密钥\ne = pc.encrypt(\"0123456789ABCDEF\") # 对输入明文进行加密 \nd = pc.decrypt(e) # 解密密文操作\nprint(e, d)\ne = pc.encrypt(\"00000000000000000000000000\")\nd = pc.decrypt(e)\nprint(e, d)\n下面我们来看下代码的运行结果：\n\npython unittest 单元测试模块\n\n\n\n\n\n\n\n\nunittest 是 python 的一个基础常用的单元测试框架，\n便于我们编写测试用例以及测试执行。其中中最核心的四个概念是:\ntest case\n\ntest suite\n\ntest runner\n\ntest fixture\n\n\nunittest 进行单元测试的流程：\n\n写好 TestCase，然后由 TestLoader 加载 TestCase 到 TestSuite\n然后由 TextTestRunner 来运行 TestSuite，运行的结果保存在 TextTestResult 中\n我们通过命令行或者 unittest.main()执行时，main 会调用 TextTestRunner 中的 run 来执行，或者我们可以直接通过 TextTestRunner 来执行用 例。\n\n一个 class 继承 unittest.TestCase 即是一个 TestCase，其中以 test 开头的方法 在 load 时被加载为一个真正的 TestCase。\n在 TestRunner 中的 verbosity 参数可以控制执行结果的输出，0 是简单报告、1 是一般报告、2 是详细报告。\n下面完成一次基本的 unittest 单元测试：\n# 准备好待测函数\ndef add(a, b): \n  return a+b\ndef minus(a, b):\n  return a-b\ndef multi(a, b):\n  return a*b\ndef divide(a, b):\n  return a/b\n\n然后写出待测函数的测试方法：\nimport unittest\nfrom mathfunc import *\n\nclass TestMathFunc(unittest.TestCase): \n  \"\"\"Test mathfuc.py\"\"\"\n\tdef setUp(cls):\n\t\tprint(\"do something before test.Prepare environment.\")\n\n  def tearDown(cls):\n\t\tprint(\"do something after test.Clean up.\")\n\n  def test_add(self):\n\t\t\"\"\"Test method add(a, b)\"\"\" \n    print(\"add\")\n\t\tself.assertEqual(3, add(1, 2)) \n    self.assertNotEqual(3, add(2, 2))\n\n  def test_minus(self):\n\t\t\"\"\"Test method minus(a, b)\"\"\" \n\t\tprint(\"minus\") \n    self.assertEqual(1, minus(3, 2))\n\n  def test_multi(self):\n\t\t\"\"\"Test method multi(a, b)\"\"\" \n    print(\"multi\") \n    self.assertEqual(6, multi(2, 3))\n\n  def test_divide(self):\n\t\t\"\"\"Test method divide(a, b)\"\"\"\n    print(\"divide\")\n\t\tself.assertEqual(2, divide(6, 3)) \n    self.assertEqual(2.5, divide(5, 2))\n    \nif __name__ == '__main__': \n  unittest.main()\n\n以上代码已经可以完成一次简单的单元测试了，但是还无法按照指定的顺序 来执行测试用例。因此我们这里使用 suite 来控制每个 case 的先后执行顺序：同 时，如果同时有多个测试文件，我们也可以通过 suite 来控制他们进行一起执行。\n# -*- coding: utf-8 -*-\nimport unittest\nfrom test_mathfunc import TestMathFunc \nfrom HTMLTestRunner import HTMLTestRunner\n\nif __name__ == '__main__':\nsuite = unittest.TestSuite() suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestMathFunc)) \nwith open('UnittestTextReport.txt', 'a') as f:\nrunner = unittest.TextTestRunner(stream=f, verbosity=2)\nrunner.run(suite)\n\n然后我们试着运行，可以看到运行结果如下：\n\n\n\n\n\n\n\n\n\n\n如果出现有 ok 的记号，则表示本次测试的结果为成功;如果出现 fail，则表 示测试结果出现问题，这时我们就需要寻找问题，看看测试结果问题在哪里。\npython assert 断言对于断言，官方有一段官方的解释:Assert statements are a convenient way toinsert debugging assertions into a program，其作用就是类似于我们 debug 的工具，\n一般的用法是:\nassert condition\n\n用来让程序测试这个 condition，如果 condition 为 false，那么 raise 一个AssertionError 出来。逻辑上等同于:\nif not condition:\n    raise AssertionError()\n\n我们来简单做一个小小的断言测试:\nassert 1==2, \"以下结果出现断言\"\n\n结果如下：\n\npython pyserial 串口模块pyserial 模块封装了对串口的访问。在支持的平台上有统一的接口，通过 python属性访问串口设置。支持不同的字节大小、停止位、校验位和流控设置。 \n在串口的配置中，有以下一些比较重要的属性需要我们了解：波特率、数据位、停止位、校验位、字节大小、读写超时设置等。 下面我们来看下对于串口的设置方法：\nimport sys\nimport glob\nimport time\nimport serial\nimport serial.tools.list_ports\n8\ndef serial_ports():\n\"\"\" Lists serial port names\n       :raises EnvironmentError:\n          On unsupported or unknown platforms\n       :returns:\n          A list of the serial ports available on the system\n\"\"\"\n# 如果是 windows 平台的系统，对应的串口号形式 if sys.platform.startswith('win'):\nports = ['COM%s' % (i + 1) for i in range(256)]\n# 如果是 Linux 平台的系统，对应的串口号形式\nelif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):\n# this excludes your current terminal \"/dev/tty\"\nports = glob.glob('/dev/tty[A-Za-z]*') # 如果是 OS X 的系统，对应的串口号形式\nelif sys.platform.startswith('darwin'):\nports = glob.glob('/dev/tty.*') else:\nraise EnvironmentError('Unsupported platform') result = []\n# 可以通过 Serial 函数对每一个串口进行控制其操作 for port in ports:\ntry:\ns = serial.Serial(port) s.close() result.append(port)\nexcept (OSError, serial.SerialException): pass\nreturn result\n# 这句命令可以在终端打印出所有的串口设备\nprint(list(serial.tools.list_ports.comports()))\nif __name__ == '__main__': print(serial_ports())\n\n下面看下我电脑上打印出来的相关串口号，可以看到一共有 3 个，表示的是每个 串口分配到的地址：\n\n","slug":"2020-2-25-pytest","date":"2020-02-25T15:00:00.000Z","categories_index":"Test","tags_index":"OS,Test","author_index":"Csuzhang"},{"id":"faf57fc67eb65f85eddb08e39325fc44","title":"Shell脚本2小时速学","content":"Shell简介Shell 是一个用 C 语言编写的程序，它是用户使用Linux的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。\n而Shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。\n创建第一个Shell脚本打开文本编辑器(我用的是macOS，可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。\n输入一些代码，第一行一般是这样：\n#!&#x2F;bin&#x2F;bash\necho &quot;Hello World !&quot;\n#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。\n运行第一个Shell脚本(1/2)\n\n\n\n\n\n\n\n\n1、作为可执行程序\n将上面的代码保存为 test.sh，并 cd 到相应目录：\nchmod +x .&#x2F;test.sh  #使脚本具有执行权限\n.&#x2F;test.sh  #执行脚本\n注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。\n\n\n\n\n\n\n\n\n\n2、作为解释器参数\n这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：\n&#x2F;bin&#x2F;sh test.sh\n&#x2F;bin&#x2F;php test.php\n\n定义Shell变量定义变量时，变量名不加美元符号（$，PHP语言中变量需要）\n注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\n\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n中间不能有空格，可以使用下划线（_）。\n不能使用标点符号。\n不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n\n\n\n\n\n\n\n\n\n除了显式地直接赋值，还可以用语句给变量赋值，如：\nfor file in &#96;ls &#x2F;etc&#96;\n或\nfor file in $(ls &#x2F;etc)\n以上语句将 /etc 下目录的文件名循环出来。\n使用Shell变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\nyour_name=\"qinjx\"\necho $your_name\necho $&#123;your_name&#125;\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\nfor skill in Ada Coffe Action Java; do\n    echo \"I am good at $&#123;skill&#125;Script\"\ndone\n\n如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n强烈推荐给所有变量加上花括号，这是个好的编程习惯。\n\n\n\n\n\n\n\n\n\n已定义的变量，可以被重新定义\n","slug":"2020-2-21-shell","date":"2020-02-21T13:00:00.000Z","categories_index":"Test","tags_index":"OS,Test,shell","author_index":"Csuzhang"},{"id":"922a078e310ed087c60322a7fd27c1cb","title":"API接口测试入门","content":"API接口测试入门\n\n\n\n\n\n\n\n\nAPI是Application Programming Interface的简写，我们又把接口测试叫做API测试，主要用于实现多个系统之间或系统内部模块之间的通信和数据交换的能力。\n1.接口定义接口测试主要用于系统与系统之间以及内部各个子系统或模块之间的交互点。定义特定的交互点，然后通过这些交互点，以及一些特殊的规则也就是协议，来进行数据之间的交互。前后端之间配合工作，就是其中一方定义实现接口，另一方来调用接口，以实现预期功能。\n举个简单的例子，我们在开车踩油门时，并不需要知道油门内部的零线/火线以及具体的电路结构，因为汽车制造商已经将给油的一系列操作全部封装成了油门这样一个接口，用户只要傻瓜式地进行踩油门的操作就可以让汽车实现加速。\n2.接口分类\n\n\n\n\n\n\n\n\nWebService和HTTP\n（1）WebService接口走soap协议，请求报文和返回报文都是xml格式，通过SoapUI工具进行测试；\n（2）HTTP API接口走HTTP协议，通过路径来区分调用的方法，请求报文入参有多种形式，返回报文一般为json串，最常见的是get和post方法。\n3.接口测试必要性（1）效率上：现在系统的复杂性与日俱增，传统测试方法人工成本过高且效率低下，而接口测试比较容易实现自动化集成，减少人工成本与时间，缩短测试周期；\n（2）安全上：前后端架构分离，只依靠前端进行测试已经完全不能满足系统安全要求，绕过前面实在太容易，需要后端同样进行控制，在这种情况下就需要从接口层面验证。\n4.接口测试原理通过程序模拟客户端向服务器发送请求报文，服务器接收请求报文后对报文做处理并向客户端返回应答，客户端再接收应答的一个过程。\n5.接口文档关键部分接口说明\n调用的url\n请求方法（get、post）\n请求参数，参数类型、请求参数说明\n返回参数说明\n返回示例\n6.接口测试分类（1）功能测试：由于是针对基本业务功能进行测试，这部分是两种测试重合度最高的一块，开发同学通常所指的也主要是这部分的内容。测试覆盖：业务流程，参数类型、可选项等。\n（2）边界分析测试：在基本功能测试的基础上考虑输入输出的边界条件。相对来说接口可以覆盖的范围很广，同样的，接口出现问题的概率也更高。测试覆盖：边界值、特殊字符等。\n（3）性能测试：接口性能主要关注接口响应时间、并发、服务端资源的使用情况等。越靠近底层，对于系统的性能优化越有利。测试覆盖：并发数、吞吐量、tps等\n7.接口测试工具Postman，jmeter，soupUI等测试工具。\n测试用例基本概念拓展\n\n\n\n\n\n\n\n\n简单来说，测试用例就是一个文档，描述输入、输出、动作、时间等，其目的是确定应用程序的某个特性是否正常工作，并且达到程序所设计的期望结果。\n测试用例的作用\n有效性\n\n避免穷举测试，选取代表性的测试数据进行测试，节省时间和资源，提高测试效率\n\n避免测试的盲目性\n\n开始测试之前设计好测试用例，避免盲目测试，使得重点突出、目的明确\n\n可维护性\n\n软件版本更新后，只需部分修正测试用例即可继续开展，降低工作强度，缩短项目周期\n\n可复用性\n\n项目功能的模块化，使软件易于开发，使得测试过程事半功倍\n\n可评估性\n\n程序代码的质量的量化标准应该用测试用例的通过率和测试输出软件缺陷的数目来进行评估\n\n可管理性\n\n测试用例是测试人员的重要参考依据，也可以作为检验测试进度、测试工作量的因素，来对测试工作进行有效管理\n测试用例的设计通常由经验丰富的测试人员设计测试用例，经验较少的人员从执行测试用例开始进行，随着经验和技术的积累，再逐渐开始参与测试用例的设计工作。\ntip1.测试设计说明类似开发人员有项目开发功能书一样，测试人员也要有说明书来指导测试人员如何设计测试用例，包括但不限于：被测特性、测试所用的方法、测试准则等。\n\n标识符\n\n被测特性\n\n方法\n\n测试用例信息\n\n通过/失败规则\n\n\ntip2.测试用例编写\n用例的编号\n\n由测试引用的唯一标识符，便于查找测试用例，也便于用例的追踪和管理\n\n测试标题\n\n对测试用例的描述，清楚表达用例的相关用途等\n\n测试项\n\n测试用例应该具体详细的描述所测试项的详细特征，更加详细具体\n\n测试环境要求\n\n该测试用例执行的外部条件，软硬件具体指标和测试工具等\n\n特殊要求\n\n对环境的特殊需求，如所需设备型号、对防火墙等的特殊设置\n\n测试输入说明\n\n提供测试执行中的各种输入条件。根据需求中的输入条件，确定测试用例的输入。\n\n操作步骤\n\n提供测试执行的过程步骤，对于复杂的用例，应该分为几个步骤分别完成测试。\n\n预期结果\n\n提供测试执行的预期结果，预期结果应该根据软件需求中的输出得出。如实际结果与预期结果不符合，则测试不通过。\n\n测试用例之间的关联\n\n用来标示该测试用例和其他测试用例之间的依赖关系。在实际测试中，很多测试用例并不是单独存在的，而是可能存在 某种相互依赖关系。\n\n测试用例设计人员和测试人员\n\n测试优先级\n\n\n一般分为0～4的一共5个等级，通过优先级来标注出软件测试的重点和先后顺序。\n测试用例的分类和阶段\n\n\n测试阶段\n测试类型\n执行人员\n\n\n\n单元测试\n模块功能测试、部分接口测试、覆盖测试、路径测试\n开发与测试结合\n\n\n集成测试\n接口测试、路径测试、部分功能测试\n开发与测试结合或测试\n\n\n系统测试\n功能测试、兼容性测试、性能测试、用户界面测试、安全性测试、强度测试、可靠性测试\n测试人员\n\n\n验收测试\n对于实际项目基本同上、包含文档测试\n测试人员或包含用户\n\n\n","slug":"2020-1-20-API-test-learning","date":"2020-01-20T12:00:00.000Z","categories_index":"Test","tags_index":"OS,Test","author_index":"Csuzhang"},{"id":"5edc0af96d039407d0a4d714c8979137","title":"Operating System 3","content":"四、进程通信定义：进程之间的信息交换\n进程是资源分配的最小单位，因此，各个进程的内存地址空间相互独立\n通常来说，为了保证安全，一个进程不能直接访问另一个的地址空间\n\n\n\n\n\n\n\n\n\n三种通信方式: 共享存储、 管道通信、消息传递\n共享存储\n设置一个共享空间，进程间互斥的进行访问；\n分为：\n\n基于数据结构的共享存储，共享速度慢，限制多，低级通信\n\n基于存储区的共享存储，内存中划分出存储区，数据形式、存储位置都由进程来控制，速度快，高级通信\n\n\n管道通信pipe\n\n\n\n\n\n\n\n\n主要用于父子进程间通信\n\n“管道”指用于连接读写进程的共享文件，称为pipe文件（内存中开辟固定大小的缓冲区）\n@Test\npublic void testPipe() throws IOException &#123;\n    // 1、获取通道\n    Pipe pipe = Pipe.open();\n\n    // 2、获取sink管道，用来传送数据\n    Pipe.SinkChannel sinkChannel = pipe.sink();\n\n    // 3、申请一定大小的缓冲区\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    byteBuffer.put(\"123232142345234\".getBytes());\n    byteBuffer.flip();\n\n    // 4、sink发送数据\n    sinkChannel.write(byteBuffer);\n\n    // 5、创建接收pipe数据的source管道\n    Pipe.SourceChannel sourceChannel = pipe.source();\n    // 6、接收数据，并保存到缓冲区中\n    ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);\n    byteBuffer2.flip();\n    int length = sourceChannel.read(byteBuffer2);\n\n    System.out.println(new String(byteBuffer2.array(), 0, length));\n\n    sourceChannel.close();\n    sinkChannel.close();\n&#125;\n\n注意：\n\n半双工通信：某时间段内只能单向传输（进程互斥进行访问），若要实现双向通信，就设置两个管道\n\n数据以字符流的形式写入管道\n\n如果没有写满，就不允许读；同样，如果没读空，就不允许写\n\npipe写满时，write()系统调用被阻塞，等待读进程将数据取走后，管道变空，read()被阻塞\n\n\n消息传递\n数据交换以格式化消息Message为单位，通过OS的“发送/接收消息”的原语进行\n消息 = 消息头 + 消息体（消息头：发送ID、接收ID、消息类型、长度）\n五、多线程概念模型引入线程的目的：提高并发度\n传统的进程是程序执行流的最小单位；有了多线程，线程就成了程序执行流的最小单位\n进程是资源分配的最小单位，线程是调度的最小单位\n\n进程间并发，需要切换进程的运行环境，开销大\n\n线程间并发，若在同一进程内，不切换环境，开销小\n\n\n属性要点\n每个线程都由独立的ID、线程控制块TCB\n\n线程几乎不拥有系统资源\n\n同一进程的线程之间共享进程的资源\n\n\n实现方式用户级线程、内核级线程\n\n\n\n\n\n\n\n\n\n用户级线程——多对一模型由应用程序通过线程池来管理实现。用户级线程中，线程切换可在用户态下完成\n理解：从用户角度可以看到的线程\n\n\n\n\n\n\n\n\n\n内核级线程——一对一模型由操作系统完成该进程的管理。内核级线程中，线程切换需要在核心态下完成\n理解：从OS内核视角看到的线程\n\n\n\n\n\n\n\n\n\n二者组合将n 个用户级线程映射到m个内核级线程（n &gt;= m）\n克服了多对一模型并发度不高的缺点，克服了一对一模型中每个用户进程占用太多资源的缺点\n通过下图进行小节下：\n\n六、CPU的调度从就绪队列中按照一定的算法选择一个进程并将CPU时间分配给他调度，实现进程的并发\n三种调度:高级调度(作业调度)、中级调度(内存调度)、低级调度(进程调度)\n\n\n\n\n\n\n\n\n\n高级调度是外存与内存之间的调度\n按一定的原则从外存上处于后备队列的作业中挑选一个或多个作业，分配内存等必要资源，建立进程\n\n\n\n\n\n\n\n\n\n中级调度提高系统内存利用率、系统吞吐量\n决定将哪个处于挂起状态的进程重新调入内存，一个进程可能多次被调出、调入内存，发生频率高于高级调度\n\n\n\n\n\n\n\n\n\n低级调度最基本的一种调度\n按照某种策略或方法，从就绪队列中选取一个进程分配CPU时间，调用的频率很高\n\n","slug":"2019-10-24-Operating-System-3","date":"2019-10-24T10:00:00.000Z","categories_index":"OS","tags_index":"OS,Linux","author_index":"Csuzhang"},{"id":"d64204ea7010a8dff7ca1f949f9be51e","title":"Operating System 2","content":"一、进程的定义、组成、组织、特征进程的定义\n进程是程序的一次执行过程\n\n进程是具有独立功能的程序在数据集合上运行的过程，是系统进行调度和资源分配的独立单元\n\n\n\n\n\n\n\n\n\n\n\n进程实体 = 程序段 + 数据段 + PCB(进程控制块)\n注意区分：进程和进程实体：进程是动态的，进程实体是静态的\n\nPCB(进程管理块):为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（Process Control Block）。它是进程实体的一部分，1.是操作系统中最重要的记录性数据结构。它是2.进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。所谓的创建进程和撤销进程，都是指对 PCB 的操作。\n程序段: 存放执行的代码；\n数据段: 存放程序运行过程中处理的各种数据；\nQuestion:\n\n\n\n\n\n\n\n\n进程控制块的作用是什么？PCB中应包括哪些信息？\n进程控制块的作用是：进程控制块用于保存每个进程和资源的相关信息，包括进程标识、空间、运行状态、资源等信息。以便于操作系统管理和控制进程和资源。PCB中应包括：1、进程标识信息：本进程的标识、父进程的标识、进程所属用户的标识。2、处理机状态信息。保存进程的运行现场信息，包括用户可用寄存器的信息；控制和状态寄存器的信息；栈指针。\n进程的组织方式是指多个进程之间的组织形式\n\n链接方式：(1)按照进程状态将PCB划分为多个队列(2)OS持有指向各个队列的指针\n\n索引方式：(1)根据进程的状态，建立几张索引表(2)OS持有指向各个索引表的指针\n\n\n一个系统中，进程成百上千，必须选择合适的合适的方式进行有效的管理。\n进程的特征\n对这块小结下：\n二、进程的状态与转换进程的5种状态3种基本状态：\n\n运行态：占有CPU，并正在运行的进程\n\n就绪态：已经分配有运行的资源和条件，可以说：“万事俱备，只欠CPU”\n\n阻塞态：等待资源的分配，这里不考虑CPU时间的分配，反正暂时不能运行\n\n\n2种过程中的状态：\n\n创建态：进程正在创建，OS为其分配资源，初始化PCB\n\n终止态：进程正在撤销，OS回收其资源，撤销PC（或者是由于bug导致进程无法继续执行，需进行撤销）\n\n\n\n\n\n\n\n\n\n\n\n\n注意以下内容:\n\n只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；\n\n而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU 时间，缺少 CPU 时间会从运行态转换为就绪态；\n\n进程只能自己阻塞自己，因为只有进程自身才知道何时需要等待某种事件的发生；\n\n\n本章小节：\n$$ Question：进程创建的主要工作是什么？\n接收进程运行现场初始值，初始优先级、执行程序描述，其它资源等参数。\n请求分配进程描述块PCB空间，得到一个内部数字进程标识。 \n用从父进程传来的参数初始化PCB表。\n产生描述进程空间的数据结构，初始化进程空间，建立程序段，数据段、栈段等。\n用进程运行现场初始值设置处理机现场保护区；造一个进程运行栈帧。\n置好父进程等关系域，同时将进程置成就绪状态。 \n将PCB表挂入就绪队列，等待时机被调度运行\n\n进程控制(即对进程进行转换)对系统中的进程进行有效管理，创建、撤销、状态切换，通过就绪队列和阻塞队列来实现状态切换\n如何实现进程切换？原语的特点：\n\n操作原子性、运行时间短、调用频繁\n\n运行在核心态，权限内非常大、属于特权指令\n\n位于操作系统最底层，最接近硬件的部分\n\n\n\n\n\n\n\n\n\n\n\n实现并发性–&gt;产生中断处理(CPU从用户态切换到核心态)–&gt;关中断指令–&gt;原语代码–&gt;开中断指令–&gt;继续中断处理\n一气呵成，不可分割\n原语的任务无外乎3点\n\n更新PCB中的信息，包括进程状态标志、保存运行环境到PCB、从PCB恢复环境等所有进程的控制原语一定修改进程状态标志，抢夺CPU的使用权，必定保存其运行环境，其进程开始运行前必定恢复运行环境\n\n将PCB插入合适的队列（就绪、阻塞队列）\n\n分配回收合适的资源\n\n\n\n\n\n\n\n\n\n\n\n进程的终止\n\n从PCB中找到终止进程\n\n若程序在运行，立即剥夺CPU，将CPU的时间分配给其他进程\n\n终止其所有子进程\n\n将该进程的所有资源归还给父进程或OS\n\n删除该PCB\n\n\n\n\n\n\n\n\n\n\n\n进程的阻塞和唤（状态切换）\n阻塞和唤醒原语必须成对使用\n\n阻塞原语：a. 找到阻塞进程对应的PCBb. 保持进程环境，PCB信息修改为“阻塞态”，暂停进程的运行c. 将PCB插入相应事件的等待队列\n\n唤醒原语：a. 在事件等待队列中找到PCBb. 将PCB从等待队列中移除，设为“就绪态”c. 将PCB插入就绪队列，等待被CPU调度\n\n\n进程的切换\n\n将运行环境存入PCB\n\nPCB移入相应的队列中\n\n选择另一个进程执行，更新其PCB\n\n根据PCB恢复新进程的运行环境\n\n\n","slug":"2019-10-23-Operating-System-2","date":"2019-10-23T10:00:00.000Z","categories_index":"OS","tags_index":"OS,Linux","author_index":"Csuzhang"},{"id":"5ef8240d710597f2ae80c2594557b77a","title":"Operating System 1","content":"OS基本概念、系统调用、中断一、操作系统特征\n并发：多个事件在同一时间间隔内同时发生，在宏观上是同时发生的，在微观上是交替发生的；\n\n区分：并行（多个事件在同一时刻同时发生，同一时刻运行多个指令，需要硬件支持：比如多处理器）\n\n共享：系统中的资源被多个并发的进程共同使用，分为互斥共享和同时共享；\n\n互斥共享：互斥共享的资源被称为临界资源，即同一时间只允许一个进程访问，需要同步机制来实现\n同时共享：同时共享比如有对硬件资源的访问\n\n虚拟：将一个物理实体转换为多个逻辑实体，分为时分复用和时分复用；\n\n时分复用：多进程在同一处理器上并发执行（类似于轮询的方式）\n空分复用：将物理内存抽象为地址空间，每个进程有各自的地址空间\n\n异步：进程不是一次执行完毕，而是走走停停。\n\nQuestion试述多道程序设计技术的基本思想。为什么采用多道程序设计技术可以提高资源利用率？\n\n\n\n\n\n\n\n\n\n多批道程序设计技术的基本思想是，在主存同时保持多道程序，主机以交替的方式同时处理多道程序。从宏观上看，主机内同时保持和处理若干道已开始运行但尚未结束的程序。从微观上看，某一时刻处理机只运行某道程序。 可以提高资源利用率的原因：由于任何一道作业的运行总是交替地串行使用CPU、外设等资源，即使用一段时间的CPU，然后使用一段时间的I/O设备，由于采用多道程序设计技术，加之对多道程序实施合理的运行调度，则可以实现CPU和I/O设备的高度并行，可以大大提高CPU与外设的利用率。\n什么是分时系统？其主要特征是什么？适用于哪些应用？\n\n\n\n\n\n\n\n\n\n分时系统是以多批道程序设计技术为基础的交互式系统，在此系统中，一台计算机与多台终端相连接，用户通过各自的终端和终端命令以交互的方式使用计算机系统。每个用户都感觉到好像是自己在独占计算机系统，而在系统内部则由操作系统以时间片轮转的方式负责协调多个用户分享CPU。 主要特征是：并行性：系统能协调多个终端用户同时使用计算机系统，能控制多道程序同时运行。共享性：对资源而言，系统在宏观上使各终端用户共享计算机系统中的各种资源，而在微观上它们则分时使用这些资源。交互性：人与计算机以交互的方式进行工作。独占性：使用户感觉到他在独占使用计算机。现在的系统大部分都是分时系统，主要应用于人机交互的方面。\n二、系统调用Definition: 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成 。\n即为操作系统的作用，作为用户和操作系统你底层硬件之间的接口，系统调用是操作系统为上层提供接口，包括有命令接口和程序接口\n通过汇编语言可以进行系统调用，而汇编语言又为C语言向上提供了接口；C语言经过封装，又为上层的高级语言提供了接口，最终形成了我们使用的高级计算机语言，比如java、phthon等。这种系统调用-&gt;汇编语言-&gt;C语言-&gt;高级语言-&gt;应用程序的模式就是硬件和用户使用的应用程序之间的交互模式，是不是很有意思呢？haha\n三、操作系统的体系结构\n\n\n\n\n\n\n\n\n\n通过程序状态寄存器PSW中的某个标记位来标记当前处理器的状态\nOS的内核程序是操作系统的管理者，运行在核心态。\n大内核、微内核：大内核相比之下多了系统资源管理部分的功能（不同操作系统，对于内核功能的划分可能不太一样）\n大内核：是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。\n微内核：操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。\n四、中断异常处理Definition：\n中断:是指来自CPU执行指令以外的事件发生后，处理机暂停正在运行的程序，转去执行处理该事件的程序的过程。\n异常:是指源自CPU执行指令内部的事件发生后，处理机暂停正在执行的程序，转去处理该事件的过程。\n区别：广义的中断包括中断和异常，统一称为中断。狭义的中断(外中断，平常说的中断)和异常的区别在于是否与正在执行的指令有关，中断可以屏蔽，而异常不可屏蔽。\n中断产生：为了实现多道程序并发执行而引入的技术\n作用：发生中断后，CPU会进入核心态\n\n\n\n\n\n\n\n\n\n中断是CPU从用户态进入核心态的唯一途径\n分类：外中断: 由 CPU 执行指令以外的事件引起，如I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。\n内中断: ①异常: 由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。②陷入: 在用户程序中使用系统调用。\n\n\n\n\n\n\n\n\n\n如何判断内外中断中断信号来自内部还是外部\n总结中断、异常和系统调用:\n\n\n类型\n源头\n响应方式\n处理机制\n\n\n\n中断(外中断)\n外设\n异步\n持续、对用户应用程序是透明的\n\n\n异常(内中断)\n应用程序未知的行为\n同步\n杀死或重新执行这些未知的应用程序指令\n\n\n系统调用\n应用程序请求操作系统提供服务\n异步或者同步\n等待和持续\n\n\nQuestion\n什么是中断向量？其内容是什么？试述中断的处理过程。\n\n中断向量：为处理方便，一般为系统中每个中断信号编制一个相应的中断处理程序，并把这些程序的入口地址放在特定的主存单元中。通常将这一片存放中断处理程序入口地址的主存单元称为中断向量。 中断向量的内容：对不同的系统，中断向量中的内容也不尽相同。一般每一个中断信号占用连续的两个单元：一个用来存放中断处理程序的入口地址，另一个用来保存在处理中断时CPU应具有的状态。 中断的处理过程：一般包括保存现场，分析中断原因，进入相应的中断处理程序，最后重新选择程序运行，恢复现场等过程。\n\n为什么要把中断分级？如何设定中断的优先级？试述多级中断的处理原则。 (有关中断优先级)\n\n为什么要把中断分级：在计算机系统中，不同的中断源可能在同一时刻向CPU发出不同的中断信号，也可能前一中断尚未处理完，紧接着又发生了新的中断。此时，存在谁先被响应和谁先被处理的优先次序问题。为了使系统能及时地响应和处理所发生的紧急中断，根据中断的轻重缓急，对各类中断规定了高低不同的响应级别。 如何设定中断的优先级：中断分级的原则是根据中断的轻重缓急来排序，把紧迫程度大致相当的中断源归并在同一级，而把紧迫程度差别较大的中断源放在不同的级别。一般来说，高速设备的中断优先级高，慢速设备的中断优先级低。 多级中断的处理原则：当多级中断同时发生时，CPU按照由高到低的顺序响应。高级中断可以打断低级中断处理程序的运行，转而执行高级中断处理程序。当同级中断同时到时，则按位响应。\n","slug":"2019-10-22-Operating-System-1","date":"2019-10-22T10:00:00.000Z","categories_index":"OS","tags_index":"OS,Linux","author_index":"Csuzhang"},{"id":"96e9bdce81e3be8f3d9c5a142492ab30","title":"深入浅出IO模型","content":"前言：每次谈到IO模型，都会牵扯到同步、异步、阻塞、非阻塞这几个词。从词的表面上看，很多人都觉得很容易理解。但是细细一想，却总会发现有点摸不着头脑。下文就结合具体的实例来讲解一下经典的几个IO模型。\n\nIO模型分类：内存IO、磁盘IO、网络IO等，通常的IO指的是后两者\n\n阻塞和非阻塞是函数的实现方式，即在数据就绪之前是立即返回还是等待，就是发起的IO是否被阻塞\n\n以文件IO为例,一个IO读过程是文件数据从磁盘→内核缓冲区→用户内存的过程。同步与异步的区别主要在于数据从内核缓冲区→用户内存这个过程需不需要用户进程等待，即实际的IO读写是否阻塞请求进程。(网络IO把磁盘换做网卡即可)\n\n\nIO模型\n\n\n\n\n\n\n\n\n同步阻塞\n如果数据没有准备就绪，就一直等待，直到数据准备就绪。\n去麦当劳吃饭，点了一个自己最喜欢的套餐，然后一直在排队等待处等到套餐做好，自己端回到餐桌上就餐。这就是典型的同步阻塞。当厨师给你做饭的时候，你需要一直在那里等着。\n\n在网络编程中，读取客户端的数据需要调用recvfrom。在默认情况下，这个调用会一直阻塞直到数据接收完毕，就是一个同步阻塞的IO方式。这也是最简单的IO模型，在通常fd较少、就绪很快的情况下使用是没有问题的。\n\n\n\n\n\n\n\n\n\n同步非阻塞\n如果没有准备就绪会返回一个标志信息，不需要等待，等到数据准备就绪以后，内核会把数据拷贝到线程中去。但是需要不断询问内核是否已经准备好数据，非阻塞虽然不用等待但是一直占用CPU。\n还是在麦当劳点餐，你每次点完饭就在那里等着，突然有一天你发现自己so stupid 。于是，你点完之后，就回桌子那里坐着，然后估计差不多了，就问服务员💁‍♂️饭好了没，如果好了就去端，没好的话就等一会再去问，循环直到饭做好，这就是同步非阻塞。\n这种方式在编程中对socket设置O_NONBLOCK即可。但此方式仅仅针对网络IO有效，对磁盘IO并没有作用。因为本地文件IO就没有被认为是阻塞，我们所说的网络IO的阻塞是因为网路IO有无限阻塞的可能，而本地文件除非是被锁住，否则是不可能无限阻塞的，因此只有锁这种情况下，O_NONBLOCK才会有作用。而且，磁盘IO时要么数据在内核缓冲区中直接可以返回，要么需要调用物理设备去读取，这时候进程的其他工作都需要等待。因此，后续的IO复用和信号驱动IO对文件IO也是没有意义的。\n\n\n\n\n\n\n\n\n\n\nIO多路复用模型\n多路复用IO，会有一个线程不断地去轮询多个socket的状态，当socket有读写事件的时候才会调用IO 读写操作。\n用一个线程管理多个socket，是通过selector.select()查询每个通道是否有事件到达，如果没有事件到达，则会一直阻塞在那里，因此也会带来线程阻塞问题。\n还是在麦当劳点餐，你点一份饭然后循环的去问好没好显然有点得不偿失，倒还不如就等在那里直到准备好；但是当你点了好几样饭菜的时候，你每次都去问一下所有饭菜的状态(未做好/已做好)肯定比你每次阻塞在那里等着好多了。当然，你问的时候是需要阻塞的，一直到有准备好的饭菜或者你等的不耐烦(超时)。这就引出了IO复用，也叫多路IO就绪通知。这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。使得一个进程能在一连串的事件上等待。\n\n\n\n\n\n\n\n\n\n可以打个比方：如果我们先前创建的几个进程承载不了目前快速发展的业务的话，是不是还得增加进程数？我们都知道系统创建进程是需要消耗大量资源的，所以这样就会导致系统资源不足的情况。\n那么有没有一种方式可以让一个进程同时为多个客户端端提供服务？\nselect模型：\n说的通俗一点就是各个客户端连接的文件描述符也就是套接字，都被放到了一个集合中，调用select函数之后会一直监视这些文件描述符中有哪些可读，如果有可读的描述符那么我们的工作进程就去读取资源。PHP 中有内置的函数来完成 select 系统调用。\npoll模型：\npoll 和 select 的实现非常类似，本质上的区别就是存放 fd 集合的数据结构不一样。select 在一个进程内可以维持最多 1024 个连接，poll 在此基础上做了加强，可以维持任意数量的连接。但 select 和 poll 方式有一个很大的问题就是，我们不难看出来 select 是通过轮训的方式来查找是否可读或者可写，打个比方，如果同时有100万个连接都没有断开，而只有一个客户端发送了数据，所以这里它还是需要循环这么多次，造成资源浪费。所以后来出现了 epoll系统调用。\nepoll模型：\nepoll 是 select 和 poll 的增强版，epoll 同 poll 一样，文件描述符数量无限制。epoll是基于内核的反射机制，在有活跃的 socket 时，系统会调用我们提前设置的回调函数。而 poll 和 select 都是遍历。\n但是也并不是所有情况下 epoll 都比 select/poll 好，比如在如下场景：在大多数客户端都很活跃的情况下，系统会把所有的回调函数都唤醒，所以会导致负载较高。既然要处理这么多的连接，那倒不如 select 遍历简单有效。\n\n\n\n\n\n\n\n\n\n\n信号驱动模型\n在信号驱动IO模型中，当用户发起一个IO请求操作时，会给对应的socket注册一个信号函数，线程会继续执行；当数据准备就绪的时候会给线程发送一个信号，线程接受到信号时，会在信号函数中进行IO操作。非阻塞IO、多路复用IO、信号驱动IO都不会造成IO操作的第一步，查看数据是否准备就绪而带来的线程阻塞，但是在第二步，对数据进行拷贝都会使线程阻塞。\n上文的麦当劳就餐情形，还是需要你每次都去问一下饭菜状况。于是，你再次不耐烦了，就跟老板说，哪个饭菜好了就通知我一声吧。然后就自己坐在桌子那里干自己的事情。或者，你可以把手机号留给老板，自己出门，等饭菜好了直接发条短信给你。这就类似信号驱动的IO模型。\n\n\n\n\n\n\n\n\n\n\n异步非阻塞\n异步IO是最理想的IO模型，当线程发出一个IO请求操作时，接着就去做自己的事情了，内核去查看数据是否准备就绪和准备就绪后对数据的拷贝，拷贝完以后内核会给线程发送一个通知说整个IO操作已经完成了，数据可以直接使用了。\n之前的就餐方式，到最后总是需要你自己去把饭菜端到餐桌。这下你也觉得不耐烦了，于是就告诉老板，能不能饭好了直接端到你的面前或者送到你的家里(外卖)。这就是异步非阻塞IO了。\n\n异步IO和信号驱动的主要区别，在于：信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。\n","slug":"2019-10-4-IO-stream","date":"2019-10-04T15:59:00.000Z","categories_index":"OS","tags_index":"Linux,OS :wq,Java","author_index":"Csuzhang"},{"id":"14750d10b608fec1c8b93e14b5886576","title":"基于MRTK的Microsoft HoloLens开发入门","content":"基于MRTK的Microsoft HoloLens开发\n\n\n\n\n\n\n\n\n背景介绍\n前段时间刚回到长沙，碰巧远大张公子的建筑公司最新开发出一种建筑材料，想要借助HoloLens MixedReality进行现场动态展示，所以我们团队将项目承接了过来，进行HoloLens真机的入门级别项目开发，并后期计划教公司的技术人员快速上手开发流程。在对方投资的一台HoloLens真机的协助下，基于MRTK进行了一些入门开发，开发过程中由于国内进行相关开发的团队过少，且微软官方近期已将原HoloToolKit改版为MixedRealityToolKit也即MRTK，能搜到的有关HoloLens开发的博客很少，且大都存在时效性，给现今开发Hololens的团队带来了巨大的挑战；而官方文档又只有英文版且对入门级别不太友好，造成开发过程中难题不断。\n所幸，在团队夜以继日连续几天的开发环境配置/查看源码/项目开发的努力下，最终将初期任务圆满完成，我已经把初版Demo的项目源码传到了GitHub上，以下是项目地址：\nhttps://github.com/zhyChesterCheung/HoloLens-Development\n\n\n\n\n\n\n\n\n\n\n下面我们将放出项目的部分演示视频，仅供大家参考\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n开发必备条件\n下面就是我们团队配置了一晚上才勉强通过的环境，大家千万小心，版本更新太快了……\n\n\n\n名称\n环境\n\n\n\nOS(macOS特别说明)\nWindows 10(家庭版除外)\n\n\nVisual Studio\nVisual Studio Community 2017及以上版本\n\n\nUnity3d\nUnity 2018.4.6f1及以上版本\n\n\nOS系统推荐强烈推荐使用windows进行U3d的开发及Visual Studio的调试，因为HoloLens本来就是微软自家的孩子，用来开发当然理所因当，而其他系统的兼容性和支持性就明显不如windows那么友好👬了，因为k配置环境到一半就会发现少了一个类似SDK的东西，叫做UWP(universal windows platform)，想将项目部署到HoloLens平台上，这个UWP是必须的，否则下一步就不要进行了，我劝你换台电脑再继续开发。\n\n\n\n\n\n\n\n\n\n对于macOS系统，我z找遍了网上所有说mac可以做开发的博客，并最终总结出：mac开发b需要装双系统或者虚拟机，其实还是逃不开windows10系统，所以劝你还是乖乖认命吧。\nVisual Studio配置Visual Studio的配置是否正确决定了项目能否成功从Unity中构建导出，进而设计能否在Hololens生成APP及调试。下面是团队经多次尝试后确认的正确配置所需选择的，建议大家不要轻易修改：\n\n\n\n\n在进行Hololens的开发时，我们需要集成微软官方提供的 MixedRealityToolKit项目。MixedRealityToolKit ，即原来的HoloToolkit-Unity项目，简称MRTK，是微软官方的开源项目，用于帮助开发者快速开发 HoloLens 应用，能够快速为项目集成基本输入、空间映射和场景匹配等特性。\n关于该项目的详细介绍，可以参考MRTK官方说明文档：https://microsoft.github.io/MixedRealityToolkit-Unity/README.html\n在Github上下载MRTK项目代码：https://github.com/microsoft/MixedRealityToolkit-Unity\n\n将下载的ZIP解压，使用Unity以打开工程的方式打开解压得到的文件夹，右击Assets，选择Export Package，将所有MRTK前缀的包全部选上，导出得到一unitypackage格式的文件，即是后续在Unity项目中可直接导入的MRTK工具包。\n\nUnity3d开发配置Unity3D是进行Hololens开发的主要平台，也是我们开发VR/AR/MR等等各种Reality的主要平台，对于各种建模和3D模型对有相对较好的支持，可以让美工/设计/开发人员共同操作的开发平台，下面是配置的步骤：使用Unity新建一个3D项目，由左上角选项栏沿Assets-import package-custom package途径引入上一步中导出的unitypackage文件。在成功导入后选项框上会出现一个新的选项——Mixed Reality Toolkit，点击并选择Add to Scene and Configure,选择添加图中高亮的MixedRealityToolKitConfigurationProfile，随即左侧框中出现MRTK及MRPlaySpace。\n\n\n\n由于Hololens内装的是UWP版的Windows 10系统，而Unity默认创建项目运行的平台即标准版本，与之不符，因而需在左上角选项栏中沿File-Build Settings去转换平台为UWP版，相关设置更改如下图，且勿漏选，错选。（笔者使用的是Unity 2018.4.6f1版本）选好后点击Switch Platform即可。\n\n仍在Building Settings中点击左下角的Player Settings，在Unity右侧的Inspector中选择XR Settings，勾选其中的Virtual Reality Support 和WSA Holographic Remoting supported。\n\n截至此步基本配置已完成，可通过Holographic Remoting Player与设备连接，点击开始即快捷地调试已有项目。注意Holographic Remoting Player是在Hololens上安装，电脑端通过Window-XR-Holographic Emulation途径打开下面的界面，Emulation Mode 选择Remote to Device，在Hololens上打开Holographic Remoting Player后即可获取Hololens的ip地址，输入到Remote Machine中即可。\n详细使用方法见：https://docs.microsoft.com/zh-cn/windows/mixed-reality/holographic-remoting-player\n\n强烈推荐在Windows Store（Windows自带）上下载Microsoft HoloLens，可实时获取设备第一视角的直播，及进行实时照相，录屏等功能，方便团队开发。\n\n\n本片博客的环境配置大多是靠队友支撑起来的，因为我用的是macOS电脑，所以最后我的电脑是无法跑起来的，但是这并不影响我对项目作出自己的贡献，我主要在项目中是负责C#脚本的编写和测试。\n这篇博客也是从队友那边参考了一部分，这里也算是注明出处：\nhttps://blog.csdn.net/Brant_Stark/article/details/100043862\n","slug":"2019-8-23-MR-HoloLens-develop","date":"2019-08-23T15:00:00.000Z","categories_index":"MixedReality","tags_index":"MR,VR,AR","author_index":"Csuzhang"},{"id":"27e94352f708afee5179b3aeeabc6de1","title":"佩剑温酒走江湖 -- 华中HackFun","content":"\n\n\n\n\n\n\n\n\n每个勇士都希望通过一段成功的经历来证明自己，但仰望星空还需脚踏实地，真正的成长道路是：输、输、输、输、输、输、输、输、输——赢！——HackFun比赛有感\n这是最近的最后一个比赛了，其他项目也陆续都结题，这次打完就要用一段时间来沉淀下自己，总结这段时间的收获与体会，争取下次参赛能够做出强者的姿态！见识到很多大牛，了解到外面的世界，眼界宽阔不少；但实力一定要能配得上自己的眼界，否则付出的功夫可能都是泡沫浮云。\n\n\n\n\n\n\n\n\n\n\n惨痛的开场\n这次我们组的路人局，没有事先找到靠谱的队友，湖大的两位学姐是真的什么都不会就来参加的(比我更勇敢)；也没有提前选择好合适的项目，造成了我们开局的不利。从比赛9点到场，到当天晚上9点之间，我们换了5个题目，每个题目都存在一定的可行性，但都被Mentor们指出了致命的错误。从知启智幼儿教育、智能货架、教育资源平台、老年人社区，到最后我们做的demo——focus基于深度学习的广告精准投递闭环，我们几乎尝遍了AI这两年普遍使用的几个方向。\n但最后选择这个项目，还是因为技术的落地性比较强，在较短的时间内能跑出一个简单的demo，后期功能的拓展性很高，而且整体项目的商业模式是我们做出的一次大胆尝试，虽然最后没有拿奖，但也为我们提供了一种全新的思路，算是收获匪浅。\n\n\n项目详情介绍\nfocus基于深度学习的广告精准投递闭环，通过插件的形式向平台出售，安装插件的平台可以通过调用用户摄像头捕捉到用户的表情；我们通过Tensorflow的LSTM模型进行对用户情感倾向判断，以表情的细微变化判断出用户在阅读广告时的情感倾向，是喜欢、厌烦、焦虑、伤心或者其他什么；我们将收集到的数据整合后反馈给广告商家，商家收到反馈后可以根据广告的实际效果，对广告进行二次精准投放，提高用户的广告体验度和广告触达效率。\n有人提到设计用户隐私问题，我们考虑过了，但judge并没有在这个方向提问。我们通过用户授权使用、签署安全条款的方式对用户的隐私进行保护，可以简单化这个问题。\n然后现场我们跑出来一个简单的demo，但由于数据集太少，识别的精确度还暂时做不到细微变化的识别，只能识别大概的情感判断。这也是评委最后pass掉我们的一个原因，说我们的产品展示效果不够好，但对比于同组出线的其他两个项目，我真心觉得我们的效果展示还算不错的了(这也是我不服的地方)。\n\n效果展示图\n下面放出效果展示图看下(比较傻帽别介哈):\n\n\n\n能做到这一步不错了，我们的训练集是小的可怜，再加上笔记本算力不够，目前只能做到不是很细微的情感判断，后期可能会继续优化下模型，再通过数据集的提高实现细微表情变化的判断。\n总体来说，这次比赛对人工智能的一些功能的应用算是有了一定的尝试，比如百度AI平台提供的多种SDK，提供语音、图像、文本、自然语言处理等多种人工智能的应用，非常方便！还有paddlepaddle和Tensorflow框架，运用都十分方便。最后冠军的项目其实没有太强的技术含量，但他们的公益性目的为他们加了不少分：\n林嘉俊和王进林两个化工院的带着两个不干活的计科的同胞，把两项已经成熟的应用结合到一起，想到了一个新的应用场景，帮助没有双手的残疾人使用电脑。通过百度人脸检测得到人脸的72个关键点，然后对返回的参数进行处理，通过头的方向的移动，实现对鼠标的移动操作；通过嘴上的15个关键点，以张嘴实现点击操作、以撅嘴实现双击操作；然后通过长时间张嘴实现输入文字，默认开始进行5秒的录音，将录音结果传送至云端进行解析，把结果返回到鼠标光标所在的位置，这样实现了打字的操作。\n输虽然是输了，但总体感觉收获还是蛮大的，算是对这类比赛的套路有了一定的了解，比赛看中的最主要的还是idea和你的效果演示，这两个做好了，加上演讲的生动形象，想不拿奖都难。接下来的时间就是沉淀阶段了，把近期的学习收获好好捋一捋，也算是没有白去体验了。\n","slug":"2019-6-1-Hackthon","date":"2019-06-01T15:00:00.000Z","categories_index":"thinking","tags_index":"thinking,Hackthon,AI","author_index":"Csuzhang"}]